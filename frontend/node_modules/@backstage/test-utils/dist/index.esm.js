import privateExports, { errorApiRef, storageApiRef, ApiTestRegistry, defaultSystemIcons } from '@backstage/core-api';
import ObservableImpl from 'zen-observable';
import { act } from '@testing-library/react';
import React from 'react';
import { MemoryRouter } from 'react-router';
import { Route } from 'react-router-dom';
import { lightTheme } from '@backstage/theme';
import { renderWithEffects } from '@backstage/test-utils-core';
export * from '@backstage/test-utils-core';

const nullObservable = {
  subscribe: () => ({unsubscribe: () => {
  }, closed: true})
};
class MockErrorApi {
  constructor(options = {}) {
    this.options = options;
    this.errors = new Array();
    this.waiters = new Set();
  }
  post(error, context) {
    if (this.options.collect) {
      this.errors.push({error, context});
      for (const waiter of this.waiters) {
        if (waiter.pattern.test(error.message)) {
          this.waiters.delete(waiter);
          waiter.resolve({error, context});
        }
      }
      return;
    }
    throw new Error(`MockErrorApi received unexpected error, ${error}`);
  }
  error$() {
    return nullObservable;
  }
  getErrors() {
    return this.errors;
  }
  waitForError(pattern, timeoutMs = 2e3) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(new Error("Timed out waiting for error"));
      }, timeoutMs);
      this.waiters.add({resolve, pattern});
    });
  }
}
MockErrorApi.factory = {
  implements: errorApiRef,
  deps: {},
  factory: () => new MockErrorApi()
};

class MockStorageApi {
  constructor(namespace, data) {
    this.subscribers = new Set();
    this.observable = new ObservableImpl((subscriber) => {
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.namespace = namespace;
    this.data = {...data};
  }
  static create(data) {
    return new MockStorageApi("", data);
  }
  forBucket(name) {
    return new MockStorageApi(`${this.namespace}/${name}`, this.data);
  }
  get(key) {
    return this.data[this.getKeyName(key)];
  }
  async set(key, data) {
    this.data[this.getKeyName(key)] = data;
    this.notifyChanges({key, newValue: data});
  }
  async remove(key) {
    delete this.data[this.getKeyName(key)];
    this.notifyChanges({key, newValue: void 0});
  }
  observe$(key) {
    return this.observable.filter(({key: messageKey}) => messageKey === key);
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(message) {
    for (const subscription of this.subscribers) {
      subscription.next(message);
    }
  }
}
MockStorageApi.factory = {
  implements: storageApiRef,
  deps: {},
  factory: () => MockStorageApi.create()
};

const queryToBreakpoint = {
  "(min-width:1920px)": "xl",
  "(min-width:1280px)": "lg",
  "(min-width:960px)": "md",
  "(min-width:600px)": "sm",
  "(min-width:0px)": "xs"
};
function toBreakpoint(query) {
  const breakpoint = queryToBreakpoint[query];
  if (!breakpoint) {
    throw new Error(`received unknown media query in breakpoint mock: '${query}'`);
  }
  return breakpoint;
}
function mockBreakpoint(initialBreakpoint = "xl") {
  let currentBreakpoint = initialBreakpoint;
  const queries = Array();
  window.matchMedia = (query) => {
    const listeners = new Set();
    const queryList = {
      addListener(listener) {
        listeners.add(listener);
      },
      removeListener(listener) {
        listeners.delete(listener);
      },
      matches: toBreakpoint(query) === currentBreakpoint
    };
    queries.push({query, queryList, listeners});
    return queryList;
  };
  return {
    set(breakpoint) {
      currentBreakpoint = breakpoint;
      act(() => {
        queries.forEach(({query, queryList, listeners}) => {
          const matches = toBreakpoint(query) === breakpoint;
          queryList.matches = matches;
          listeners.forEach((listener) => listener({matches}));
        });
      });
    },
    remove() {
      delete window.matchMedia;
    }
  };
}

function createMockApiRegistry() {
  const registry = new ApiTestRegistry();
  registry.register(MockErrorApi.factory);
  registry.register(MockStorageApi.factory);
  return registry;
}

const {PrivateAppImpl} = privateExports;
const NotFoundErrorPage = () => {
  throw new Error("Reached NotFound Page");
};
const BootErrorPage = ({step, error}) => {
  throw new Error(`Reached BootError Page at step ${step} with error ${error}`);
};
const Progress = () => /* @__PURE__ */ React.createElement("div", {
  "data-testid": "progress"
});
function wrapInTestApp(Component, options = {}) {
  const {routeEntries = ["/"]} = options;
  const apis = createMockApiRegistry();
  const app = new PrivateAppImpl({
    apis,
    components: {
      NotFoundErrorPage,
      BootErrorPage,
      Progress,
      Router: ({children}) => /* @__PURE__ */ React.createElement(MemoryRouter, {
        initialEntries: routeEntries,
        children
      })
    },
    icons: defaultSystemIcons,
    plugins: [],
    themes: [
      {
        id: "light",
        theme: lightTheme,
        title: "Test App Theme",
        variant: "light"
      }
    ]
  });
  let Wrapper;
  if (Component instanceof Function) {
    Wrapper = Component;
  } else {
    Wrapper = () => Component;
  }
  const AppProvider = app.getProvider();
  const AppRouter = app.getRouter();
  return /* @__PURE__ */ React.createElement(AppProvider, null, /* @__PURE__ */ React.createElement(AppRouter, null, /* @__PURE__ */ React.createElement(Route, {
    path: "*",
    element: /* @__PURE__ */ React.createElement(Wrapper, null)
  })));
}
async function renderInTestApp(Component, options = {}) {
  return renderWithEffects(wrapInTestApp(Component, options));
}

export { MockErrorApi, MockStorageApi, mockBreakpoint, renderInTestApp, wrapInTestApp };
