/// <reference types="react" />
import React, { FC, ReactNode, ComponentType, ComponentClass, FunctionComponent } from 'react';
import { BackstageTheme } from '@backstage/theme';
import { Config, AppConfig } from '@backstage/config';
export { ConfigReader } from '@backstage/config';
import { OverrideProps } from '@material-ui/core/OverridableComponent';
import { SvgIconProps } from '@material-ui/core';
import { Observable as Observable$1 } from '@backstage/core';

declare type ApiRefConfig = {
    id: string;
    description: string;
};
declare type ApiRef<T> = {
    id: string;
    description: string;
    T: T;
};
declare function createApiRef<T>(config: ApiRefConfig): ApiRef<T>;

declare type AnyApiRef = ApiRef<any>;
declare type ApiRefType<T> = T extends ApiRef<infer U> ? U : never;
declare type TypesToApiRefs<T> = {
    [key in keyof T]: ApiRef<T[key]>;
};
declare type ApiRefsToTypes<T extends {
    [key in any]: ApiRef<any>;
}> = {
    [key in keyof T]: ApiRefType<T[key]>;
};
declare type ApiHolder = {
    get<T>(api: ApiRef<T>): T | undefined;
};
declare type ApiFactory<Api, Impl, Deps> = {
    implements: ApiRef<Api>;
    deps: TypesToApiRefs<Deps>;
    factory(deps: Deps): Impl extends Api ? Impl : never;
};

declare type ApiProviderProps = {
    apis: ApiHolder;
    children: ReactNode;
};
declare const ApiProvider: FC<ApiProviderProps>;
declare function useApiHolder(): ApiHolder;
declare function useApi<T>(apiRef: ApiRef<T>): T;

declare type ApiImpl<T = unknown> = readonly [ApiRef<T>, T];
declare class ApiRegistryBuilder {
    private apis;
    add<T, I extends T>(api: ApiRef<T>, impl: I): I;
    build(): ApiRegistry;
}
declare class ApiRegistry implements ApiHolder {
    private readonly apis;
    static builder(): ApiRegistryBuilder;
    static from(apis: ApiImpl[]): ApiRegistry;
    /**
     * Creates a new ApiRegistry with a single API implementation.
     *
     * @param api ApiRef for the API to add
     * @param impl Implementation of the API to add
     */
    static with<T>(api: ApiRef<T>, impl: T): ApiRegistry;
    constructor(apis: Map<ApiRef<unknown>, unknown>);
    /**
     * Returns a new ApiRegistry with the provided API added to the existing ones.
     *
     * @param api ApiRef for the API to add
     * @param impl Implementation of the API to add
     */
    with<T>(api: ApiRef<T>, impl: T): ApiRegistry;
    get<T>(api: ApiRef<T>): T | undefined;
}

declare class ApiTestRegistry implements ApiHolder {
    private readonly apis;
    private factories;
    private savedFactories;
    get<T>(ref: ApiRef<T>): T | undefined;
    register<A, I, D>(factory: ApiFactory<A, I, D>): ApiTestRegistry;
    reset(): void;
    save(): ApiTestRegistry;
    private load;
    private loadDeps;
}

/**
 * Used to infer types for a standalone ApiFactory that isn't immediately passed
 * to another function.
 * This function doesn't actually do anything, it's only used to infer types.
 */
declare function createApiFactory<Api, Impl, Deps>(factory: ApiFactory<Api, Impl, Deps>): ApiFactory<Api, Impl, Deps>;

/**
 * This file contains declarations for common interfaces of auth-related APIs.
 * The declarations should be used to signal which type of authentication and
 * authorization methods each separate auth provider supports.
 *
 * For example, a Google OAuth provider that supports OAuth 2 and OpenID Connect,
 * would be declared as follows:
 *
 * const googleAuthApiRef = createApiRef<OAuthApi & OpenIDConnectApi>({ ... })
 */
/**
 * An array of scopes, or a scope string formatted according to the
 * auth provider, which is typically a space separated list.
 *
 * See the documentation for each auth provider for the list of scopes
 * supported by each provider.
 */
declare type OAuthScope = string | string[];
declare type AuthRequestOptions = {
    /**
     * If this is set to true, the user will not be prompted to log in,
     * and an empty response will be returned if there is no existing session.
     *
     * This can be used to perform a check whether the user is logged in, or if you don't
     * want to force a user to be logged in, but provide functionality if they already are.
     *
     * @default false
     */
    optional?: boolean;
    /**
     * If this is set to true, the request will bypass the regular oauth login modal
     * and open the login popup directly.
     *
     * The method must be called synchronously from a user action for this to work in all browsers.
     *
     * @default false
     */
    instantPopup?: boolean;
};
/**
 * This API provides access to OAuth 2 credentials. It lets you request access tokens,
 * which can be used to act on behalf of the user when talking to APIs.
 */
declare type OAuthApi = {
    /**
     * Requests an OAuth 2 Access Token, optionally with a set of scopes. The access token allows
     * you to make requests on behalf of the user, and the copes may grant you broader access, depending
     * on the auth provider.
     *
     * Each auth provider has separate handling of scope, so you need to look at the documentation
     * for each one to know what scope you need to request.
     *
     * This method is cheap and should be called each time an access token is used. Do not for example
     * store the access token in React component state, as that could cause the token to expire. Instead
     * fetch a new access token for each request.
     *
     * Be sure to include all required scopes when requesting an access token. When testing your implementation
     * it is best to log out the Backstage session and then visit your plugin page directly, as
     * you might already have some required scopes in your existing session. Not requesting the correct
     * scopes can lead to 403 or other authorization errors, which can be tricky to debug.
     *
     * If the user has not yet granted access to the provider and the set of requested scopes, the user
     * will be prompted to log in. The returned promise will not resolve until the user has
     * successfully logged in. The returned promise can be rejected, but only if the user rejects the login request.
     */
    getAccessToken(scope?: OAuthScope, options?: AuthRequestOptions): Promise<string>;
    /**
     * Log out the user's session. This will reload the page.
     */
    logout(): Promise<void>;
};
/**
 * This API provides access to OpenID Connect credentials. It lets you request ID tokens,
 * which can be passed to backend services to prove the user's identity.
 */
declare type OpenIdConnectApi = {
    /**
     * Requests an OpenID Connect ID Token.
     *
     * This method is cheap and should be called each time an ID token is used. Do not for example
     * store the id token in React component state, as that could cause the token to expire. Instead
     * fetch a new id token for each request.
     *
     * If the user has not yet logged in to Google inside Backstage, the user will be prompted
     * to log in. The returned promise will not resolve until the user has successfully logged in.
     * The returned promise can be rejected, but only if the user rejects the login request.
     */
    getIdToken(options?: AuthRequestOptions): Promise<string>;
    /**
     * Log out the user's session. This will reload the page.
     */
    logout(): Promise<void>;
};
/**
 * This API provides access to profile information of the user from an auth provider.
 */
declare type ProfileInfoApi = {
    /**
     * Get profile information for the user as supplied by this auth provider.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
};
/**
 * This API provides access to the user's identity within Backstage.
 *
 * An auth provider that implements this interface can be used to sign-in to backstage. It is
 * not intended to be used directly from a plugin, but instead serves as a connection between
 * this authentication method and the app's @IdentityApi
 */
declare type BackstageIdentityApi = {
    /**
     * Get the user's identity within Backstage. This should normally not be called directly,
     * use the @IdentityApi instead.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
};
declare type BackstageIdentity = {
    /**
     * The backstage user ID.
     */
    id: string;
    /**
     * An ID token that can be used to authenticate the user within Backstage.
     */
    idToken: string;
};
/**
 * Profile information of the user.
 */
declare type ProfileInfo = {
    /**
     * Email ID.
     */
    email?: string;
    /**
     * Display name that can be presented to the user.
     */
    displayName?: string;
    /**
     * URL to an avatar image of the user.
     */
    picture?: string;
};
/**
 * Session state values passed to subscribers of the SessionStateApi.
 */
declare enum SessionState {
    SignedIn = "SignedIn",
    SignedOut = "SignedOut"
}
/**
 * This API provides access to an sessionState$ observable which provides an update when the
 * user performs a sign in or sign out from an auth provider.
 */
declare type SessionStateApi = {
    sessionState$(): Observable<SessionState>;
};
/**
 * Provides authentication towards Google APIs and identities.
 *
 * See https://developers.google.com/identity/protocols/googlescopes for a full list of supported scopes.
 *
 * Note that the ID token payload is only guaranteed to contain the user's numerical Google ID,
 * email and expiration information. Do not rely on any other fields, as they might not be present.
 */
declare const googleAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionStateApi>;
/**
 * Provides authentication towards Github APIs.
 *
 * See https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/
 * for a full list of supported scopes.
 */
declare const githubAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionStateApi>;
/**
 * Provides authentication towards Okta APIs.
 *
 * See https://developer.okta.com/docs/guides/implement-oauth-for-okta/scopes/
 * for a full list of supported scopes.
 */
declare const oktaAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionStateApi>;
/**
 * Provides authentication towards Gitlab APIs.
 *
 * See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html#limiting-scopes-of-a-personal-access-token
 * for a full list of supported scopes.
 */
declare const gitlabAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionStateApi>;
/**
 * Provides authentication for custom identity providers.
 */
declare const oauth2ApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & SessionStateApi>;

/**
 * This file contains non-react related core types used throught Backstage.
 */
/**
 * Observer interface for consuming an Observer, see TC39.
 */
declare type Observer<T> = {
    next?(value: T): void;
    error?(error: Error): void;
    complete?(): void;
};
/**
 * Subscription returned when subscribing to an Observable, see TC39.
 */
declare type Subscription = {
    /**
     * Cancels the subscription
     */
    unsubscribe(): void;
    /**
     * Value indicating whether the subscription is closed.
     */
    readonly closed: Boolean;
};
/**
 * Observable sequence of values and errors, see TC39.
 *
 * https://github.com/tc39/proposal-observable
 *
 * This is used as a common return type for observable values and can be created
 * using many different observable implementations, such as zen-observable or RxJS 5.
 */
declare type Observable<T> = {
    /**
     * Subscribes to this observable to start receiving new values.
     */
    subscribe(observer: Observer<T>): Subscription;
    subscribe(onNext: (value: T) => void, onError?: (error: Error) => void, onComplete?: () => void): Subscription;
};

declare type AlertMessage = {
    message: string;
    severity?: 'success' | 'info' | 'warning' | 'error';
};
/**
 * The alert API is used to report alerts to the app, and display them to the user.
 */
declare type AlertApi = {
    /**
     * Post an alert for handling by the application.
     */
    post(alert: AlertMessage): void;
    /**
     * Observe alerts posted by other parts of the application.
     */
    alert$(): Observable<AlertMessage>;
};
declare const alertApiRef: ApiRef<AlertApi>;

/**
 * Describes a theme provided by the app.
 */
declare type AppTheme = {
    /**
     * ID used to remember theme selections.
     */
    id: string;
    /**
     * Title of the theme
     */
    title: string;
    /**
     * Theme variant
     */
    variant: 'light' | 'dark';
    /**
     * The specialized MaterialUI theme instance.
     */
    theme: BackstageTheme;
};
/**
 * The AppThemeApi gives access to the current app theme, and allows switching
 * to other options that have been registered as a part of the App.
 */
declare type AppThemeApi = {
    /**
     * Get a list of available themes.
     */
    getInstalledThemes(): AppTheme[];
    /**
     * Observe the currently selected theme. A value of undefined means no specific theme has been selected.
     */
    activeThemeId$(): Observable<string | undefined>;
    /**
     * Get the current theme ID. Returns undefined if no specific theme is selected.
     */
    getActiveThemeId(): string | undefined;
    /**
     * Set a specific theme to use in the app, overriding the default theme selection.
     *
     * Clear the selection by passing in undefined.
     */
    setActiveThemeId(themeId?: string): void;
};
declare const appThemeApiRef: ApiRef<AppThemeApi>;

interface ConfigApi extends Config {
}
declare const configApiRef: ApiRef<ConfigApi>;

/**
 * Mirrors the javascript Error class, for the purpose of
 * providing documentation and optional fields.
 */
declare type Error$1 = {
    name: string;
    message: string;
    stack?: string;
};
/**
 * Provides additional information about an error that was posted to the application.
 */
declare type ErrorContext = {
    hidden?: boolean;
};
/**
 * The error API is used to report errors to the app, and display them to the user.
 *
 * Plugins can use this API as a method of displaying errors to the user, but also
 * to report errors for collection by error reporting services.
 *
 * If an error can be displayed inline, e.g. as feedback in a form, that should be
 * preferred over relying on this API to display the error. The main use of this api
 * for displaying errors should be for asynchronous errors, such as a failing background process.
 *
 * Even if an error is displayed inline, it should still be reported through this api
 * if it would be useful to collect or log it for debugging purposes, but with
 * the hidden flag set. For example, an error arising from form field validation
 * should probably not be reported, while a failed REST call would be useful to report.
 */
declare type ErrorApi = {
    /**
     * Post an error for handling by the application.
     */
    post(error: Error$1, context?: ErrorContext): void;
    /**
     * Observe errors posted by other parts of the application.
     */
    error$(): Observable<{
        error: Error$1;
        context?: ErrorContext;
    }>;
};
declare const errorApiRef: ApiRef<ErrorApi>;

declare type IconComponent = ComponentType<SvgIconProps>;
declare type SystemIconKey = 'user' | 'group';
declare type SystemIcons = {
    [key in SystemIconKey]: IconComponent;
};

declare const defaultSystemIcons: SystemIcons;
declare const UserIcon: React.ComponentType<OverrideProps<import("@material-ui/core").SvgIconTypeMap<{}, "svg">, "svg">>;
declare const GroupIcon: React.ComponentType<OverrideProps<import("@material-ui/core").SvgIconTypeMap<{}, "svg">, "svg">>;

declare type RouteRef = {
    path: string;
    icon?: IconComponent;
    title: string;
};
declare type RouteRefConfig = {
    path: string;
    icon?: IconComponent;
    title: string;
};
declare type RouteRefOverrideConfig = {
    path?: string;
    icon?: IconComponent;
    title?: string;
};

declare class MutableRouteRef {
    private readonly config;
    private effectiveConfig;
    constructor(config: RouteRefConfig);
    override(overrideConfig: RouteRefOverrideConfig): void;
    get icon(): ComponentClass<import("@material-ui/core/OverridableComponent").OverrideProps<import("@material-ui/core").SvgIconTypeMap<{}, "svg">, "svg">, any> | FunctionComponent<import("@material-ui/core/OverridableComponent").OverrideProps<import("@material-ui/core").SvgIconTypeMap<{}, "svg">, "svg">> | undefined;
    get path(): string;
    get title(): string;
}
declare function createRouteRef(config: RouteRefConfig): MutableRouteRef;

declare type RouteOptions = {
    exact?: boolean;
};
declare type RoutePath = string;
declare type LegacyRouteOutput = {
    type: 'legacy-route';
    path: RoutePath;
    component: ComponentType<{}>;
    options?: RouteOptions;
};
declare type RouteOutput = {
    type: 'route';
    target: RouteRef;
    component: ComponentType<{}>;
    options?: RouteOptions;
};
declare type RedirectRouteOutput = {
    type: 'redirect-route';
    from: RouteRef;
    to: RouteRef;
    options?: RouteOptions;
};
declare type LegacyRedirectRouteOutput = {
    type: 'legacy-redirect-route';
    path: RoutePath;
    target: RoutePath;
    options?: RouteOptions;
};
declare type FeatureFlagName = string;
declare type FeatureFlagOutput = {
    type: 'feature-flag';
    name: FeatureFlagName;
};
declare type PluginOutput = LegacyRouteOutput | RouteOutput | LegacyRedirectRouteOutput | RedirectRouteOutput | FeatureFlagOutput;
declare type BackstagePlugin = {
    getId(): string;
    output(): PluginOutput[];
};

/**
 * The UserFlags class.
 *
 * This acts as a data structure for the user's feature flags. You
 * can use this to retrieve, add, edit, delete, clear and save the user's
 * feature flags to the local browser for persisted storage.
 */
declare class UserFlags extends Map<FeatureFlagName, FeatureFlagState> {
    static load(): UserFlags;
    get(name: FeatureFlagName): FeatureFlagState;
    set(name: FeatureFlagName, state: FeatureFlagState): this;
    delete(name: FeatureFlagName): boolean;
    clear(): void;
    save(): void;
    toObject(): {};
    toJSON(): string;
    toString(): string;
}
/**
 * The FeatureFlagsRegistry class.
 *
 * This acts as a holding data structure for feature flags
 * that plugins wish to register for use in Backstage.
 */
interface FeatureFlagsRegistryItem {
    pluginId: string;
    name: FeatureFlagName;
}
declare class FeatureFlagsRegistry extends Array<FeatureFlagsRegistryItem> {
    static from(entries: FeatureFlagsRegistryItem[]): FeatureFlagsRegistry;
    push(...entries: FeatureFlagsRegistryItem[]): number;
    concat(...entries: (FeatureFlagsRegistryItem | ConcatArray<FeatureFlagsRegistryItem>)[]): FeatureFlagsRegistryItem[];
    toObject(): FeatureFlagsRegistryItem[];
    toJSON(): string;
    toString(): string;
}
/**
 * Create the FeatureFlags implementation based on the API.
 */
declare class FeatureFlags implements FeatureFlagsApi {
    registeredFeatureFlags: FeatureFlagsRegistryItem[];
    private userFlags;
    getFlags(): UserFlags;
    getRegisteredFlags(): FeatureFlagsRegistry;
}

/**
 * The feature flags API is used to toggle functionality to users across plugins and Backstage.
 *
 * Plugins can use this API to register feature flags that they have available
 * for users to enable/disable, and this API will centralize the current user's
 * state of which feature flags they would like to enable.
 *
 * This is ideal for Backstage plugins, as well as your own App, to trial incomplete
 * or unstable upcoming features. Although there will be a common interface for users
 * to enable and disable feature flags, this API acts as another way to enable/disable.
 */
declare enum FeatureFlagState {
    Off = 0,
    On = 1
}
interface FeatureFlagsApi {
    /**
     * Store a list of registered feature flags.
     */
    registeredFeatureFlags: FeatureFlagsRegistryItem[];
    /**
     * Get a list of all feature flags from the current user.
     */
    getFlags(): UserFlags;
    /**
     * Get a list of all registered flags.
     */
    getRegisteredFlags(): FeatureFlagsRegistry;
}
declare const featureFlagsApiRef: ApiRef<FeatureFlagsApi>;

/**
 * The Identity API used to identify and get information about the signed in user.
 */
declare type IdentityApi = {
    /**
     * The ID of the signed in user. This ID is not meant to be presented to the user, but used
     * as an opaque string to pass on to backends or use in frontend logic.
     *
     * TODO: The intention of the user ID is to be able to tie the user to an identity
     *       that is known by the catalog and/or identity backend. It should for example
     *       be possible to fetch all owned components using this ID.
     */
    getUserId(): string;
    /**
     * The profile of the signed in user.
     */
    getProfile(): ProfileInfo;
    /**
     * An OpenID Connect ID Token which proves the identity of the signed in user.
     *
     * The ID token will be undefined if the signed in user does not have a verified
     * identity, such as a demo user or mocked user for e2e tests.
     */
    getIdToken(): Promise<string | undefined>;
    /**
     * Log out the current user
     */
    logout(): Promise<void>;
};
declare const identityApiRef: ApiRef<IdentityApi>;

/**
 * Information about the auth provider that we're requesting a login towards.
 *
 * This should be shown to the user so that they can be informed about what login is being requested
 * before a popup is shown.
 */
declare type AuthProvider = {
    /**
     * Title for the auth provider, for example "GitHub"
     */
    title: string;
    /**
     * Icon for the auth provider.
     */
    icon: IconComponent;
};
/**
 * Describes how to handle auth requests. Both how to show them to the user, and what to do when
 * the user accesses the auth request.
 */
declare type AuthRequesterOptions<AuthResponse> = {
    /**
     * Information about the auth provider, which will be forwarded to auth requests.
     */
    provider: AuthProvider;
    /**
     * Implementation of the auth flow, which will be called synchronously when
     * trigger() is called on an auth requests.
     */
    onAuthRequest(scopes: Set<string>): Promise<AuthResponse>;
};
/**
 * Function used to trigger new auth requests for a set of scopes.
 *
 * The returned promise will resolve to the same value returned by the onAuthRequest in the
 * AuthRequesterOptions. Or rejected, if the request is rejected.
 *
 * This function can be called multiple times before the promise resolves. All calls
 * will be merged into one request, and the scopes forwarded to the onAuthRequest will be the
 * union of all requested scopes.
 */
declare type AuthRequester<AuthResponse> = (scopes: Set<string>) => Promise<AuthResponse>;
/**
 * An pending auth request for a single auth provider. The request will remain in this pending
 * state until either reject() or trigger() is called.
 *
 * Any new requests for the same provider are merged into the existing pending request, meaning
 * there will only ever be a single pending request for a given provider.
 */
declare type PendingAuthRequest = {
    /**
     * Information about the auth provider, as given in the AuthRequesterOptions
     */
    provider: AuthProvider;
    /**
     * Rejects the request, causing all pending AuthRequester calls to fail with "RejectedError".
     */
    reject: () => void;
    /**
     * Trigger the auth request to continue the auth flow, by for example showing a popup.
     *
     * Synchronously calls onAuthRequest with all scope currently in the request.
     */
    trigger(): Promise<void>;
};
/**
 * Provides helpers for implemented OAuth login flows within Backstage.
 */
declare type OAuthRequestApi = {
    /**
     * A utility for showing login popups or similar things, and merging together multiple requests for
     * different scopes into one request that inclues all scopes.
     *
     * The passed in options provide information about the login provider, and how to handle auth requests.
     *
     * The returned AuthRequester function is used to request login with new scopes. These requests
     * are merged together and forwarded to the auth handler, as soon as a consumer of auth requests
     * triggers an auth flow.
     *
     * See AuthRequesterOptions, AuthRequester, and handleAuthRequests for more info.
     */
    createAuthRequester<AuthResponse>(options: AuthRequesterOptions<AuthResponse>): AuthRequester<AuthResponse>;
    /**
     * Observers panding auth requests. The returned observable will emit all
     * current active auth request, at most one for each created auth requester.
     *
     * Each request has its own info about the login provider, forwarded from the auth requester options.
     *
     * Depending on user interaction, the request should either be rejected, or used to trigger the auth handler.
     * If the request is rejected, all pending AuthRequester calls will fail with a "RejectedError".
     * If a auth is triggered, and the auth handler resolves successfully, then all currently pending
     * AuthRequester calls will resolve to the value returned by the onAuthRequest call.
     */
    authRequest$(): Observable<PendingAuthRequest[]>;
};
declare const oauthRequestApiRef: ApiRef<OAuthRequestApi>;

declare type StorageValueChange<T = any> = {
    key: string;
    newValue?: T;
};
declare type CreateStorageApiOptions = {
    errorApi: ErrorApi;
    namespace?: string;
};
interface StorageApi {
    /**
     * Create a bucket to store data in.
     * @param {String} name Namespace for the storage to be stored under,
     *                      will inherit previous namespaces too
     */
    forBucket(name: string): StorageApi;
    /**
     * Get the current value for persistent data, use observe$ to be notified of updates.
     *
     * @param {String} key Unique key associated with the data.
     * @return {Object} data The data that should is stored.
     */
    get<T>(key: string): T | undefined;
    /**
     * Remove persistent data.
     *
     * @param {String} key Unique key associated with the data.
     */
    remove(key: string): Promise<void>;
    /**
     * Save persistant data, and emit messages to anyone that is using observe$ for this key
     *
     * @param {String} key Unique key associated with the data.
     */
    set(key: string, data: any): Promise<void>;
    /**
     * Observe changes on a particular key in the bucket
     * @param {String} key Unique key associated with the data
     */
    observe$<T>(key: string): Observable<StorageValueChange<T>>;
}
declare const storageApiRef: ApiRef<StorageApi>;

declare type GithubSession = {
    providerInfo: {
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type GetSessionOptions = {
    optional?: boolean;
    instantPopup?: boolean;
    scopes?: Set<string>;
};
/**
 * A sessions manager keeps track of the current session and makes sure that
 * multiple simultaneous requests for sessions with different scope are handled
 * in a correct way.
 */
declare type SessionManager<T> = {
    getSession(options: GetSessionOptions): Promise<T | undefined>;
    removeSession(): Promise<void>;
    sessionState$(): Observable<SessionState>;
};

declare type CreateOptions = {
    apiOrigin: string;
    basePath: string;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class GithubAuth implements OAuthApi, SessionStateApi {
    private readonly sessionManager;
    static create({ apiOrigin, basePath, environment, provider, oauthRequestApi, }: CreateOptions): GithubAuth;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<GithubSession>);
    getAccessToken(scope?: string, options?: AuthRequestOptions): Promise<string>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    logout(): Promise<void>;
    static normalizeScope(scope?: string): Set<string>;
}

declare type GitlabSession = {
    providerInfo: {
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type CreateOptions$1 = {
    apiOrigin: string;
    basePath: string;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class GitlabAuth implements OAuthApi, SessionStateApi {
    private readonly sessionManager;
    static create({ apiOrigin, basePath, environment, provider, oauthRequestApi, }: CreateOptions$1): GitlabAuth;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<GitlabSession>);
    getAccessToken(scope?: string, options?: AuthRequestOptions): Promise<string>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    logout(): Promise<void>;
    static normalizeScope(scope?: string): Set<string>;
}

declare type GoogleSession = {
    providerInfo: {
        idToken: string;
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type CreateOptions$2 = {
    apiOrigin: string;
    basePath: string;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class GoogleAuth implements OAuthApi, OpenIdConnectApi, ProfileInfoApi, BackstageIdentityApi, SessionStateApi {
    private readonly sessionManager;
    static create({ apiOrigin, basePath, environment, provider, oauthRequestApi, }: CreateOptions$2): GoogleAuth;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<GoogleSession>);
    getAccessToken(scope?: string | string[], options?: AuthRequestOptions): Promise<string>;
    getIdToken(options?: AuthRequestOptions): Promise<string>;
    logout(): Promise<void>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    static normalizeScopes(scopes?: string | string[]): Set<string>;
}

declare type OAuth2Session = {
    providerInfo: {
        idToken: string;
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type CreateOptions$3 = {
    apiOrigin: string;
    basePath: string;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class OAuth2 implements OAuthApi, OpenIdConnectApi, ProfileInfoApi, SessionStateApi {
    private readonly sessionManager;
    static create({ apiOrigin, basePath, environment, provider, oauthRequestApi, }: CreateOptions$3): OAuth2;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<OAuth2Session>);
    getAccessToken(scope?: string | string[], options?: AuthRequestOptions): Promise<string>;
    getIdToken(options?: AuthRequestOptions): Promise<string>;
    logout(): Promise<void>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    static normalizeScopes(scopes?: string | string[]): Set<string>;
}

declare type OktaSession = {
    providerInfo: {
        idToken: string;
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type CreateOptions$4 = {
    apiOrigin: string;
    basePath: string;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class OktaAuth implements OAuthApi, OpenIdConnectApi, ProfileInfoApi, BackstageIdentityApi, SessionStateApi {
    private readonly sessionManager;
    static create({ apiOrigin, basePath, environment, provider, oauthRequestApi, }: CreateOptions$4): OktaAuth;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<OktaSession>);
    getAccessToken(scope?: string, options?: AuthRequestOptions): Promise<string>;
    getIdToken(options?: AuthRequestOptions): Promise<string>;
    logout(): Promise<void>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    static normalizeScopes(scopes?: string | string[]): Set<string>;
}

/**
 * Base implementation for the AlertApi that simply forwards alerts to consumers.
 */
declare class AlertApiForwarder implements AlertApi {
    private readonly subject;
    post(alert: AlertMessage): void;
    alert$(): Observable<AlertMessage>;
}

declare class AppThemeSelector implements AppThemeApi {
    private readonly themes;
    static createWithStorage(themes: AppTheme[]): AppThemeSelector;
    private activeThemeId;
    private readonly subject;
    constructor(themes: AppTheme[]);
    getInstalledThemes(): AppTheme[];
    activeThemeId$(): Observable<string | undefined>;
    getActiveThemeId(): string | undefined;
    setActiveThemeId(themeId?: string): void;
}

/**
 * Decorates an ErrorApi by also forwarding error messages
 * to the alertApi with an 'error' severity.
 */
declare class ErrorAlerter implements ErrorApi {
    private readonly alertApi;
    private readonly errorApi;
    constructor(alertApi: AlertApi, errorApi: ErrorApi);
    post(error: Error, context?: ErrorContext): void;
    error$(): Observable$1<{
        error: {
            name: string;
            message: string;
            stack?: string | undefined;
        };
        context?: ErrorContext | undefined;
    }>;
}

/**
 * Base implementation for the ErrorApi that simply forwards errors to consumers.
 */
declare class ErrorApiForwarder implements ErrorApi {
    private readonly subject;
    post(error: Error, context?: ErrorContext): void;
    error$(): Observable<{
        error: Error;
        context?: ErrorContext;
    }>;
}

/**
 * The OAuthRequestManager is an implementation of the OAuthRequestApi.
 *
 * The purpose of this class and the API is to read a stream of incoming requests
 * of OAuth access tokens from different providers with varying scope, and funnel
 * them all together into a single request for each OAuth provider.
 */
declare class OAuthRequestManager implements OAuthRequestApi {
    private readonly subject;
    private currentRequests;
    private handlerCount;
    createAuthRequester<T>(options: AuthRequesterOptions<T>): AuthRequester<T>;
    private makeAuthRequest;
    authRequest$(): Observable<PendingAuthRequest[]>;
}

declare class WebStorage implements StorageApi {
    private readonly namespace;
    private readonly errorApi;
    constructor(namespace: string, errorApi: ErrorApi);
    static create(options: CreateStorageApiOptions): WebStorage;
    get<T>(key: string): T | undefined;
    forBucket(name: string): WebStorage;
    set<T>(key: string, data: T): Promise<void>;
    remove(key: string): Promise<void>;
    observe$<T>(key: string): Observable<StorageValueChange<T>>;
    private getKeyName;
    private notifyChanges;
    private subscribers;
    private readonly observable;
}

declare type PluginConfig = {
    id: string;
    register?(hooks: PluginHooks): void;
};
declare type PluginHooks = {
    router: RouterHooks;
    featureFlags: FeatureFlagsHooks;
};
declare type RouterHooks = {
    addRoute(target: RouteRef, Component: ComponentType<any>, options?: RouteOptions): void;
    /**
     * @deprecated See the `addRoute` method
     */
    registerRoute(path: RoutePath, Component: ComponentType<any>, options?: RouteOptions): void;
};
declare type FeatureFlagsHooks = {
    register(name: FeatureFlagName): void;
};
declare function createPlugin(config: PluginConfig): BackstagePlugin;

declare type BootErrorPageProps = {
    step: 'load-config';
    error: Error;
};
declare type SignInResult = {
    /**
     * User ID that will be returned by the IdentityApi
     */
    userId: string;
    profile: ProfileInfo;
    /**
     * Function used to retrieve an ID token for the signed in user.
     */
    getIdToken?: () => Promise<string>;
    /**
     * Logout handler that will be called if the user requests a logout.
     */
    logout?: () => Promise<void>;
};
declare type SignInPageProps = {
    /**
     * Set the sign-in result for the app. This should only be called once.
     */
    onResult(result: SignInResult): void;
};
declare type AppComponents = {
    NotFoundErrorPage: ComponentType<{}>;
    BootErrorPage: ComponentType<BootErrorPageProps>;
    Progress: ComponentType<{}>;
    Router: ComponentType<{}>;
    /**
     * An optional sign-in page that will be rendered instead of the AppRouter at startup.
     *
     * If a sign-in page is set, it will always be shown before the app, and it is up
     * to the sign-in page to handle e.g. saving of login methods for subsequent visits.
     *
     * The sign-in page will be displayed until it has passed up a result to the parent,
     * and which point the AppRouter and all of its children will be rendered instead.
     */
    SignInPage?: ComponentType<SignInPageProps>;
};
/**
 * A function that loads in the App config that will be accessible via the ConfigApi.
 *
 * If multiple config objects are returned in the array, values in the earlier configs
 * will override later ones.
 */
declare type AppConfigLoader = () => Promise<AppConfig[]>;
declare type Apis = ApiHolder | ((config: ConfigApi) => ApiHolder);
declare type AppOptions = {
    /**
     * A holder of all APIs available in the app.
     *
     * Use for example ApiRegistry or ApiTestRegistry.
     */
    apis?: Apis;
    /**
     * Supply icons to override the default ones.
     */
    icons?: Partial<SystemIcons>;
    /**
     * A list of all plugins to include in the app.
     */
    plugins?: BackstagePlugin[];
    /**
     * Supply components to the app to override the default ones.
     */
    components?: Partial<AppComponents>;
    /**
     * Themes provided as a part of the app. By default two themes are included, one
     * light variant of the default backstage theme, and one dark.
     *
     * This is the default config:
     *
     * ```
     * [{
     *   id: 'light',
     *   title: 'Light Theme',
     *   variant: 'light',
     *   theme: lightTheme,
     * }, {
     *   id: 'dark',
     *   title: 'Dark Theme',
     *   variant: 'dark',
     *   theme: darkTheme,
     * }]
     * ```
     */
    themes?: AppTheme[];
    /**
     * A function that loads in App configuration that will be accessible via
     * the ConfigApi.
     *
     * Defaults to an empty config.
     *
     * TODO(Rugvip): Omitting this should instead default to loading in configuration
     *  that was packaged by the backstage-cli and default docker container boot script.
     */
    configLoader?: AppConfigLoader;
};
declare type BackstageApp = {
    /**
     * Get the holder for all APIs available in the app.
     */
    getApis(): ApiHolder;
    /**
     * Returns all plugins registered for the app.
     */
    getPlugins(): BackstagePlugin[];
    /**
     * Get a common icon for this app.
     */
    getSystemIcon(key: SystemIconKey): IconComponent;
    /**
     * Provider component that should wrap the Router created with getRouter()
     * and any other components that need to be within the app context.
     */
    getProvider(): ComponentType<{}>;
    /**
     * Router component that should wrap the App Routes create with getRoutes()
     * and any other components that should only be available while signed in.
     */
    getRouter(): ComponentType<{}>;
    /**
     * Routes component that contains all routes for plugin pages in the app.
     */
    getRoutes(): ComponentType<{}>;
};

declare const useApp: () => BackstageApp;

declare type FullAppOptions = {
    apis: Apis;
    icons: SystemIcons;
    plugins: BackstagePlugin[];
    components: AppComponents;
    themes: AppTheme[];
    configLoader?: AppConfigLoader;
};
declare class PrivateAppImpl implements BackstageApp {
    private apis?;
    private readonly icons;
    private readonly plugins;
    private readonly components;
    private readonly themes;
    private readonly configLoader?;
    private readonly identityApi;
    private apisOrFactory;
    constructor(options: FullAppOptions);
    getApis(): ApiHolder;
    getPlugins(): BackstagePlugin[];
    getSystemIcon(key: SystemIconKey): IconComponent;
    getRoutes(): ComponentType<{}>;
    getProvider(): ComponentType<{}>;
    getRouter(): ComponentType<{}>;
    verify(): void;
}

type privateExports_PrivateAppImpl = PrivateAppImpl;
declare const privateExports_PrivateAppImpl: typeof PrivateAppImpl;
declare namespace privateExports {
  export {
    privateExports_PrivateAppImpl as PrivateAppImpl,
  };
}

export default privateExports;
export { AlertApi, AlertApiForwarder, AlertMessage, AnyApiRef, ApiFactory, ApiHolder, ApiProvider, ApiRef, ApiRefConfig, ApiRefType, ApiRefsToTypes, ApiRegistry, ApiTestRegistry, Apis, AppComponents, AppConfigLoader, AppOptions, AppTheme, AppThemeApi, AppThemeSelector, AuthProvider, AuthRequestOptions, AuthRequester, AuthRequesterOptions, BackstageApp, BackstageIdentity, BackstageIdentityApi, BackstagePlugin, BootErrorPageProps, ConfigApi, CreateStorageApiOptions, ErrorAlerter, ErrorApi, ErrorApiForwarder, ErrorContext, FeatureFlagName, FeatureFlagOutput, FeatureFlagState, FeatureFlags, FeatureFlagsApi, GithubAuth, GithubSession, GitlabAuth, GitlabSession, GoogleAuth, GoogleSession, GroupIcon, IconComponent, IdentityApi, LegacyRedirectRouteOutput, LegacyRouteOutput, MutableRouteRef, OAuth2, OAuth2Session, OAuthApi, OAuthRequestApi, OAuthRequestManager, OAuthScope, Observable, Observer, OktaAuth, OktaSession, OpenIdConnectApi, PendingAuthRequest, PluginOutput, ProfileInfo, ProfileInfoApi, RedirectRouteOutput, RouteOptions, RouteOutput, RoutePath, RouteRef, RouteRefConfig, RouteRefOverrideConfig, SessionState, SessionStateApi, SignInPageProps, SignInResult, StorageApi, StorageValueChange, Subscription, SystemIconKey, SystemIcons, TypesToApiRefs, UserIcon, WebStorage, alertApiRef, appThemeApiRef, configApiRef, createApiFactory, createApiRef, createPlugin, createRouteRef, defaultSystemIcons, errorApiRef, featureFlagsApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, oauth2ApiRef, oauthRequestApiRef, oktaAuthApiRef, storageApiRef, useApi, useApiHolder, useApp };
