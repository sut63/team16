import React, { createContext, useContext, useMemo, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import GithubIcon from '@material-ui/icons/AcUnit';
import ObservableImpl from 'zen-observable';
import { ConfigReader } from '@backstage/config';
export { ConfigReader } from '@backstage/config';
import PeopleIcon from '@material-ui/icons/People';
import PersonIcon from '@material-ui/icons/Person';
import { Navigate, Route, Routes } from 'react-router-dom';
import { ThemeProvider, CssBaseline } from '@material-ui/core';
import { useObservable, useAsync } from 'react-use';

class ApiAggregator {
  constructor(...holders) {
    this.holders = holders;
  }
  get(apiRef) {
    for (const holder of this.holders) {
      const api = holder.get(apiRef);
      if (api) {
        return api;
      }
    }
    return void 0;
  }
}

const Context = createContext(void 0);
const ApiProvider = ({apis, children}) => {
  const parentHolder = useContext(Context);
  const holder = parentHolder ? new ApiAggregator(apis, parentHolder) : apis;
  return /* @__PURE__ */ React.createElement(Context.Provider, {
    value: holder,
    children
  });
};
ApiProvider.propTypes = {
  apis: PropTypes.shape({get: PropTypes.func.isRequired}).isRequired,
  children: PropTypes.node
};
function useApiHolder() {
  const apiHolder = useContext(Context);
  if (!apiHolder) {
    throw new Error("No ApiProvider available in react context");
  }
  return apiHolder;
}
function useApi(apiRef) {
  const apiHolder = useApiHolder();
  const api = apiHolder.get(apiRef);
  if (!api) {
    throw new Error(`No implementation available for ${apiRef}`);
  }
  return api;
}

class ApiRegistryBuilder {
  constructor() {
    this.apis = [];
  }
  add(api, impl) {
    this.apis.push([api, impl]);
    return impl;
  }
  build() {
    return new ApiRegistry(new Map(this.apis));
  }
}
class ApiRegistry {
  constructor(apis) {
    this.apis = apis;
  }
  static builder() {
    return new ApiRegistryBuilder();
  }
  static from(apis) {
    return new ApiRegistry(new Map(apis));
  }
  static with(api, impl) {
    return new ApiRegistry(new Map([[api, impl]]));
  }
  with(api, impl) {
    return new ApiRegistry(new Map([...this.apis, [api, impl]]));
  }
  get(api) {
    return this.apis.get(api);
  }
}

class ApiTestRegistry {
  constructor() {
    this.apis = new Map();
    this.factories = new Map();
    this.savedFactories = new Map();
  }
  get(ref) {
    return this.load(ref);
  }
  register(factory) {
    this.factories.set(factory.implements, factory);
    return this;
  }
  reset() {
    this.factories = this.savedFactories;
    this.apis.clear();
  }
  save() {
    this.savedFactories = new Map(this.factories);
    return this;
  }
  load(ref, loading = []) {
    const impl = this.apis.get(ref);
    if (impl) {
      return impl;
    }
    const factory = this.factories.get(ref);
    if (!factory) {
      return void 0;
    }
    if (loading.includes(factory.implements)) {
      throw new Error(`Circular dependency of api factory for ${factory.implements}`);
    }
    const deps = this.loadDeps(ref, factory.deps, [
      ...loading,
      factory.implements
    ]);
    const api = factory.factory(deps);
    this.apis.set(ref, api);
    return api;
  }
  loadDeps(dependent, apis, loading) {
    const impls = {};
    for (const key in apis) {
      if (apis.hasOwnProperty(key)) {
        const ref = apis[key];
        const api = this.load(ref, loading);
        if (!api) {
          throw new Error(`No API factory available for dependency ${ref} of dependent ${dependent}`);
        }
        impls[key] = api;
      }
    }
    return impls;
  }
}

class ApiRefImpl {
  constructor(config) {
    this.config = config;
    const valid = config.id.split(".").flatMap((part) => part.split("-")).every((part) => part.match(/^[a-z][a-z0-9]*$/));
    if (!valid) {
      throw new Error(`API id must only contain period separated lowercase alphanum tokens with dashes, got '${config.id}'`);
    }
  }
  get id() {
    return this.config.id;
  }
  get description() {
    return this.config.description;
  }
  get T() {
    throw new Error(`tried to read ApiRef.T of ${this}`);
  }
  toString() {
    return `apiRef{${this.config.id}}`;
  }
}
function createApiRef(config) {
  return new ApiRefImpl(config);
}

function createApiFactory(factory) {
  return factory;
}

var SessionState;
(function(SessionState2) {
  SessionState2["SignedIn"] = "SignedIn";
  SessionState2["SignedOut"] = "SignedOut";
})(SessionState || (SessionState = {}));
const googleAuthApiRef = createApiRef({
  id: "core.auth.google",
  description: "Provides authentication towards Google APIs and identities"
});
const githubAuthApiRef = createApiRef({
  id: "core.auth.github",
  description: "Provides authentication towards Github APIs"
});
const oktaAuthApiRef = createApiRef({
  id: "core.auth.okta",
  description: "Provides authentication towards Okta APIs"
});
const gitlabAuthApiRef = createApiRef({
  id: "core.auth.gitlab",
  description: "Provides authentication towards Gitlab APIs"
});
const oauth2ApiRef = createApiRef({
  id: "core.auth.oauth2",
  description: "Example of how to use oauth2 custom provider"
});

const alertApiRef = createApiRef({
  id: "core.alert",
  description: "Used to report alerts and forward them to the app"
});

const appThemeApiRef = createApiRef({
  id: "core.apptheme",
  description: "API Used to configure the app theme, and enumerate options"
});

const configApiRef = createApiRef({
  id: "core.config",
  description: "Used to access runtime configuration"
});

const errorApiRef = createApiRef({
  id: "core.error",
  description: "Used to report errors and forward them to the app"
});

var FeatureFlagState;
(function(FeatureFlagState2) {
  FeatureFlagState2[FeatureFlagState2["Off"] = 0] = "Off";
  FeatureFlagState2[FeatureFlagState2["On"] = 1] = "On";
})(FeatureFlagState || (FeatureFlagState = {}));
const featureFlagsApiRef = createApiRef({
  id: "core.featureflags",
  description: "Used to toggle functionality in features across Backstage"
});

const identityApiRef = createApiRef({
  id: "core.identity",
  description: "Provides access to the identity of the signed in user"
});

const oauthRequestApiRef = createApiRef({
  id: "core.oauthrequest",
  description: "An API for implementing unified OAuth flows in Backstage"
});

const storageApiRef = createApiRef({
  id: "core.storage",
  description: "Provides the ability to store data which is unique to the user"
});

function showLoginPopup(options) {
  return new Promise((resolve, reject) => {
    const width = options.width || 500;
    const height = options.height || 700;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;
    const popup = window.open(options.url, options.name, `menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=${width},height=${height},top=${top},left=${left}`);
    if (!popup || typeof popup.closed === "undefined" || popup.closed) {
      reject(new Error("Failed to open auth popup."));
      return;
    }
    const messageListener = (event) => {
      if (event.source !== popup) {
        return;
      }
      if (event.origin !== options.origin) {
        return;
      }
      const {data} = event;
      if (data.type !== "authorization_response") {
        return;
      }
      const authResult = data;
      if ("error" in authResult) {
        const error = new Error(authResult.error.message);
        error.name = authResult.error.name;
        reject(error);
      } else {
        resolve(authResult.response);
      }
      done();
    };
    const intervalId = setInterval(() => {
      if (popup.closed) {
        const error = new Error("Login failed, popup was closed");
        error.name = "PopupClosedError";
        reject(error);
        done();
      }
    }, 100);
    function done() {
      window.removeEventListener("message", messageListener);
      clearInterval(intervalId);
    }
    window.addEventListener("message", messageListener);
  });
}

const DEFAULT_BASE_PATH = "/api/auth/";
function defaultJoinScopes(scopes) {
  return [...scopes].join(" ");
}
class DefaultAuthConnector {
  constructor(options) {
    const {
      apiOrigin = window.location.origin,
      basePath = DEFAULT_BASE_PATH,
      environment,
      provider,
      joinScopes = defaultJoinScopes,
      oauthRequestApi,
      sessionTransform = (id) => id
    } = options;
    this.authRequester = oauthRequestApi.createAuthRequester({
      provider,
      onAuthRequest: (scopes) => this.showPopup(scopes)
    });
    this.apiOrigin = apiOrigin;
    this.basePath = basePath;
    this.environment = environment;
    this.provider = provider;
    this.joinScopesFunc = joinScopes;
    this.sessionTransform = sessionTransform;
  }
  async createSession(options) {
    if (options.instantPopup) {
      return this.showPopup(options.scopes);
    }
    return this.authRequester(options.scopes);
  }
  async refreshSession() {
    const res = await fetch(this.buildUrl("/refresh", {optional: true}), {
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Auth refresh request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Auth refresh request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
    const authInfo = await res.json();
    if (authInfo.error) {
      const error = new Error(authInfo.error.message);
      if (authInfo.error.name) {
        error.name = authInfo.error.name;
      }
      throw error;
    }
    return await this.sessionTransform(authInfo);
  }
  async removeSession() {
    const res = await fetch(this.buildUrl("/logout"), {
      method: "POST",
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Logout request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Logout request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
  }
  async showPopup(scopes) {
    const scope = this.joinScopesFunc(scopes);
    const popupUrl = this.buildUrl("/start", {scope});
    const payload = await showLoginPopup({
      url: popupUrl,
      name: `${this.provider.title} Login`,
      origin: this.apiOrigin,
      width: 450,
      height: 730
    });
    return await this.sessionTransform(payload);
  }
  buildUrl(path, query) {
    const queryString = this.buildQueryString({
      ...query,
      env: this.environment
    });
    return `${this.apiOrigin}${this.basePath}${this.provider.id}${path}${queryString}`;
  }
  buildQueryString(query) {
    if (!query) {
      return "";
    }
    const queryString = Object.entries(query).map(([key, value]) => {
      if (typeof value === "string") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      } else if (value) {
        return encodeURIComponent(key);
      }
      return void 0;
    }).filter(Boolean).join("&");
    if (!queryString) {
      return "";
    }
    return `?${queryString}`;
  }
}

function hasScopes(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
class SessionScopeHelper {
  constructor(options) {
    this.options = options;
  }
  sessionExistsAndHasScope(session, scopes) {
    if (!session) {
      return false;
    }
    if (!scopes) {
      return true;
    }
    const sessionScopes = this.options.sessionScopes(session);
    return hasScopes(sessionScopes, scopes);
  }
  getExtendedScope(session, scopes) {
    const newScope = new Set(this.options.defaultScopes);
    if (session) {
      const sessionScopes = this.options.sessionScopes(session);
      for (const scope of sessionScopes) {
        newScope.add(scope);
      }
    }
    if (scopes) {
      for (const scope of scopes) {
        newScope.add(scope);
      }
    }
    return newScope;
  }
}

class PublishSubject {
  constructor() {
    this.isClosed = false;
    this.observable = new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}
class BehaviorSubject {
  constructor(value) {
    this.isClosed = false;
    this.observable = new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      subscriber.next(this.currentValue);
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
    this.currentValue = value;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.currentValue = value;
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}

class SessionStateTracker {
  constructor() {
    this.subject = new BehaviorSubject(SessionState.SignedOut);
    this.signedIn = false;
  }
  setIsSignedIn(isSignedIn) {
    if (this.signedIn !== isSignedIn) {
      this.signedIn = isSignedIn;
      this.subject.next(this.signedIn ? SessionState.SignedIn : SessionState.SignedOut);
    }
  }
  sessionState$() {
    return this.subject;
  }
}

class RefreshingAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {
      connector,
      defaultScopes = new Set(),
      sessionScopes,
      sessionShouldRefresh
    } = options;
    this.connector = connector;
    this.sessionScopesFunc = sessionScopes;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(this.currentSession);
      if (!shouldRefresh) {
        return this.currentSession;
      }
      try {
        const refreshedSession = await this.collapsedSessionRefresh();
        const currentScopes = this.sessionScopesFunc(this.currentSession);
        const refreshedScopes = this.sessionScopesFunc(refreshedSession);
        if (hasScopes(refreshedScopes, currentScopes)) {
          this.currentSession = refreshedSession;
        }
        return refreshedSession;
      } catch (error) {
        if (options.optional) {
          return void 0;
        }
        throw error;
      }
    }
    if (!this.currentSession) {
      try {
        const newSession = await this.collapsedSessionRefresh();
        this.currentSession = newSession;
        return this.getSession(options);
      } catch {
      }
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
  async collapsedSessionRefresh() {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    this.refreshPromise = this.connector.refreshSession();
    try {
      const session = await this.refreshPromise;
      this.stateTracker.setIsSignedIn(true);
      return session;
    } finally {
      delete this.refreshPromise;
    }
  }
}

class StaticAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {connector, defaultScopes = new Set(), sessionScopes} = options;
    this.connector = connector;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      return this.currentSession;
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
}

class AuthSessionStore {
  constructor(options) {
    const {
      manager,
      storageKey,
      sessionScopes,
      sessionShouldRefresh = () => false
    } = options;
    this.manager = manager;
    this.storageKey = storageKey;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({
      sessionScopes,
      defaultScopes: new Set()
    });
  }
  async getSession(options) {
    const {scopes} = options;
    const session = this.loadSession();
    if (this.helper.sessionExistsAndHasScope(session, scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(session);
      if (!shouldRefresh) {
        return session;
      }
    }
    const newSession = await this.manager.getSession(options);
    this.saveSession(newSession);
    return newSession;
  }
  async removeSession() {
    localStorage.removeItem(this.storageKey);
    await this.manager.removeSession();
  }
  sessionState$() {
    return this.manager.sessionState$();
  }
  loadSession() {
    try {
      const sessionJson = localStorage.getItem(this.storageKey);
      if (sessionJson) {
        const session = JSON.parse(sessionJson, (_key, value) => {
          if ((value == null ? void 0 : value.__type) === "Set") {
            return new Set(value.__value);
          }
          return value;
        });
        return session;
      }
      return void 0;
    } catch (error) {
      localStorage.removeItem(this.storageKey);
      return void 0;
    }
  }
  saveSession(session) {
    if (session === void 0) {
      localStorage.removeItem(this.storageKey);
    } else {
      localStorage.setItem(this.storageKey, JSON.stringify(session, (_key, value) => {
        if (value instanceof Set) {
          return {
            __type: "Set",
            __value: Array.from(value)
          };
        }
        return value;
      }));
    }
  }
}

const DEFAULT_PROVIDER = {
  id: "github",
  title: "Github",
  icon: GithubIcon
};
class GithubAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    apiOrigin,
    basePath,
    environment = "development",
    provider = DEFAULT_PROVIDER,
    oauthRequestApi
  }) {
    const connector = new DefaultAuthConnector({
      apiOrigin,
      basePath,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            accessToken: res.providerInfo.accessToken,
            scopes: GithubAuth.normalizeScope(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new StaticAuthSessionManager({
      connector,
      defaultScopes: new Set(["read:user"]),
      sessionScopes: (session) => session.providerInfo.scopes
    });
    const authSessionStore = new AuthSessionStore({
      manager: sessionManager,
      storageKey: "githubSession",
      sessionScopes: (session) => session.providerInfo.scopes
    });
    return new GithubAuth(authSessionStore);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: GithubAuth.normalizeScope(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  async logout() {
    await this.sessionManager.removeSession();
  }
  static normalizeScope(scope) {
    if (!scope) {
      return new Set();
    }
    const scopeList = Array.isArray(scope) ? scope : scope.split(/[\s|,]/).filter(Boolean);
    return new Set(scopeList);
  }
}

const DEFAULT_PROVIDER$1 = {
  id: "gitlab",
  title: "Gitlab",
  icon: GithubIcon
};
class GitlabAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    apiOrigin,
    basePath,
    environment = "development",
    provider = DEFAULT_PROVIDER$1,
    oauthRequestApi
  }) {
    const connector = new DefaultAuthConnector({
      apiOrigin,
      basePath,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            accessToken: res.providerInfo.accessToken,
            scopes: GitlabAuth.normalizeScope(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new StaticAuthSessionManager({
      connector,
      defaultScopes: new Set(["read_user"]),
      sessionScopes: (session) => session.providerInfo.scopes
    });
    return new GitlabAuth(sessionManager);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: GitlabAuth.normalizeScope(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  async logout() {
    await this.sessionManager.removeSession();
  }
  static normalizeScope(scope) {
    if (!scope) {
      return new Set();
    }
    const scopeList = Array.isArray(scope) ? scope : scope.split(" ");
    return new Set(scopeList);
  }
}

const DEFAULT_PROVIDER$2 = {
  id: "google",
  title: "Google",
  icon: GithubIcon
};
const SCOPE_PREFIX = "https://www.googleapis.com/auth/";
class GoogleAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    apiOrigin,
    basePath,
    environment = "development",
    provider = DEFAULT_PROVIDER$2,
    oauthRequestApi
  }) {
    const connector = new DefaultAuthConnector({
      apiOrigin,
      basePath,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            idToken: res.providerInfo.idToken,
            accessToken: res.providerInfo.accessToken,
            scopes: GoogleAuth.normalizeScopes(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new RefreshingAuthSessionManager({
      connector,
      defaultScopes: new Set([
        "openid",
        `${SCOPE_PREFIX}userinfo.email`,
        `${SCOPE_PREFIX}userinfo.profile`
      ]),
      sessionScopes: (session) => session.providerInfo.scopes,
      sessionShouldRefresh: (session) => {
        const expiresInSec = (session.providerInfo.expiresAt.getTime() - Date.now()) / 1e3;
        return expiresInSec < 60 * 5;
      }
    });
    return new GoogleAuth(sessionManager);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: GoogleAuth.normalizeScopes(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getIdToken(options = {}) {
    var _a;
    const session = await this.sessionManager.getSession(options);
    return (_a = session == null ? void 0 : session.providerInfo.idToken) != null ? _a : "";
  }
  async logout() {
    await this.sessionManager.removeSession();
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScopes(scopes) {
    if (!scopes) {
      return new Set();
    }
    const scopeList = Array.isArray(scopes) ? scopes : scopes.split(/[\s]/).filter(Boolean);
    const normalizedScopes = scopeList.map((scope) => {
      if (scope === "openid") {
        return scope;
      }
      if (scope === "profile" || scope === "email") {
        return `${SCOPE_PREFIX}userinfo.${scope}`;
      }
      if (scope.startsWith(SCOPE_PREFIX)) {
        return scope;
      }
      return `${SCOPE_PREFIX}${scope}`;
    });
    return new Set(normalizedScopes);
  }
}

const DEFAULT_PROVIDER$3 = {
  id: "oauth2",
  title: "Your Identity Provider",
  icon: GithubIcon
};
const SCOPE_PREFIX$1 = "";
class OAuth2 {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    apiOrigin,
    basePath,
    environment = "development",
    provider = DEFAULT_PROVIDER$3,
    oauthRequestApi
  }) {
    const connector = new DefaultAuthConnector({
      apiOrigin,
      basePath,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            idToken: res.providerInfo.idToken,
            accessToken: res.providerInfo.accessToken,
            scopes: OAuth2.normalizeScopes(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new RefreshingAuthSessionManager({
      connector,
      defaultScopes: new Set([
        "openid",
        `${SCOPE_PREFIX$1}userinfo.email`,
        `${SCOPE_PREFIX$1}userinfo.profile`
      ]),
      sessionScopes: (session) => session.providerInfo.scopes,
      sessionShouldRefresh: (session) => {
        const expiresInSec = (session.providerInfo.expiresAt.getTime() - Date.now()) / 1e3;
        return expiresInSec < 60 * 5;
      }
    });
    return new OAuth2(sessionManager);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const normalizedScopes = OAuth2.normalizeScopes(scope);
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: normalizedScopes
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getIdToken(options = {}) {
    var _a;
    const session = await this.sessionManager.getSession(options);
    return (_a = session == null ? void 0 : session.providerInfo.idToken) != null ? _a : "";
  }
  async logout() {
    await this.sessionManager.removeSession();
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScopes(scopes) {
    if (!scopes) {
      return new Set();
    }
    const scopeList = Array.isArray(scopes) ? scopes : scopes.split(/[\s]/).filter(Boolean);
    return new Set(scopeList);
  }
}

const DEFAULT_PROVIDER$4 = {
  id: "okta",
  title: "Okta",
  icon: GithubIcon
};
const OKTA_OIDC_SCOPES = new Set(["openid", "profile", "email", "phone", "address", "groups", "offline_access"]);
const OKTA_SCOPE_PREFIX = "okta.";
class OktaAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    apiOrigin,
    basePath,
    environment = "development",
    provider = DEFAULT_PROVIDER$4,
    oauthRequestApi
  }) {
    const connector = new DefaultAuthConnector({
      apiOrigin,
      basePath,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            idToken: res.providerInfo.idToken,
            accessToken: res.providerInfo.accessToken,
            scopes: OktaAuth.normalizeScopes(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new RefreshingAuthSessionManager({
      connector,
      defaultScopes: new Set([
        "openid",
        "email",
        "profile",
        "offline_access"
      ]),
      sessionScopes: (session) => session.scopes,
      sessionShouldRefresh: (session) => {
        const expiresInSec = (session.providerInfo.expiresAt.getTime() - Date.now()) / 1e3;
        return expiresInSec < 60 * 5;
      }
    });
    return new OktaAuth(sessionManager);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: OktaAuth.normalizeScopes(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getIdToken(options = {}) {
    var _a;
    const session = await this.sessionManager.getSession(options);
    return (_a = session == null ? void 0 : session.providerInfo.idToken) != null ? _a : "";
  }
  async logout() {
    await this.sessionManager.removeSession();
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScopes(scopes) {
    if (!scopes) {
      return new Set();
    }
    const scopeList = Array.isArray(scopes) ? scopes : scopes.split(/[\s|,]/).filter(Boolean);
    const normalizedScopes = scopeList.map((scope) => {
      if (OKTA_OIDC_SCOPES.has(scope)) {
        return scope;
      }
      if (scope.startsWith(OKTA_SCOPE_PREFIX)) {
        return scope;
      }
      return `${OKTA_SCOPE_PREFIX}${scope}`;
    });
    return new Set(normalizedScopes);
  }
}

class AlertApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(alert) {
    this.subject.next(alert);
  }
  alert$() {
    return this.subject;
  }
}

const STORAGE_KEY = "theme";
class AppThemeSelector {
  constructor(themes) {
    this.themes = themes;
    this.subject = new BehaviorSubject(void 0);
  }
  static createWithStorage(themes) {
    var _a;
    const selector = new AppThemeSelector(themes);
    if (!window.localStorage) {
      return selector;
    }
    const initialThemeId = (_a = window.localStorage.getItem(STORAGE_KEY)) != null ? _a : void 0;
    selector.setActiveThemeId(initialThemeId);
    selector.activeThemeId$().subscribe((themeId) => {
      if (themeId) {
        window.localStorage.setItem(STORAGE_KEY, themeId);
      } else {
        window.localStorage.removeItem(STORAGE_KEY);
      }
    });
    window.addEventListener("storage", (event) => {
      var _a2;
      if (event.key === STORAGE_KEY) {
        const themeId = (_a2 = localStorage.getItem(STORAGE_KEY)) != null ? _a2 : void 0;
        selector.setActiveThemeId(themeId);
      }
    });
    return selector;
  }
  getInstalledThemes() {
    return this.themes.slice();
  }
  activeThemeId$() {
    return this.subject;
  }
  getActiveThemeId() {
    return this.activeThemeId;
  }
  setActiveThemeId(themeId) {
    this.activeThemeId = themeId;
    this.subject.next(themeId);
  }
}

class ErrorAlerter {
  constructor(alertApi, errorApi) {
    this.alertApi = alertApi;
    this.errorApi = errorApi;
  }
  post(error, context) {
    if (!(context == null ? void 0 : context.hidden)) {
      this.alertApi.post({message: error.message, severity: "error"});
    }
    return this.errorApi.post(error, context);
  }
  error$() {
    return this.errorApi.error$();
  }
}

class ErrorApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(error, context) {
    this.subject.next({error, context});
  }
  error$() {
    return this.subject;
  }
}

function hasScopes$1(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
function joinScopes(scopes, ...moreScopess) {
  const result = new Set(scopes);
  for (const moreScopes of moreScopess) {
    for (const scope of moreScopes) {
      result.add(scope);
    }
  }
  return result;
}
class OAuthPendingRequests {
  constructor() {
    this.requests = [];
    this.subject = new BehaviorSubject(this.getCurrentPending());
  }
  request(scopes) {
    return new Promise((resolve, reject) => {
      this.requests.push({scopes, resolve, reject});
      this.subject.next(this.getCurrentPending());
    });
  }
  resolve(scopes, result) {
    this.requests = this.requests.filter((request) => {
      if (hasScopes$1(scopes, request.scopes)) {
        request.resolve(result);
        return false;
      }
      return true;
    });
    this.subject.next(this.getCurrentPending());
  }
  reject(error) {
    this.requests.forEach((request) => request.reject(error));
    this.requests = [];
    this.subject.next(this.getCurrentPending());
  }
  pending() {
    return this.subject;
  }
  getCurrentPending() {
    const currentScopes = this.requests.length === 0 ? void 0 : this.requests.slice(1).reduce((acc, current) => joinScopes(acc, current.scopes), this.requests[0].scopes);
    return {
      scopes: currentScopes,
      resolve: (value) => {
        if (currentScopes) {
          this.resolve(currentScopes, value);
        }
      },
      reject: (reason) => {
        if (currentScopes) {
          this.reject(reason);
        }
      }
    };
  }
}

class OAuthRequestManager {
  constructor() {
    this.subject = new BehaviorSubject([]);
    this.currentRequests = [];
    this.handlerCount = 0;
  }
  createAuthRequester(options) {
    const handler = new OAuthPendingRequests();
    const index = this.handlerCount;
    this.handlerCount++;
    handler.pending().subscribe({
      next: (scopeRequest) => {
        const newRequests = this.currentRequests.slice();
        const request = this.makeAuthRequest(scopeRequest, options);
        if (!request) {
          delete newRequests[index];
        } else {
          newRequests[index] = request;
        }
        this.currentRequests = newRequests;
        this.subject.next(newRequests.filter(Boolean));
      }
    });
    return (scopes) => {
      return handler.request(scopes);
    };
  }
  makeAuthRequest(request, options) {
    const {scopes} = request;
    if (!scopes) {
      return void 0;
    }
    return {
      provider: options.provider,
      trigger: async () => {
        const result = await options.onAuthRequest(scopes);
        request.resolve(result);
      },
      reject: () => {
        const error = new Error("Login failed, rejected by user");
        error.name = "RejectedError";
        request.reject(error);
      }
    };
  }
  authRequest$() {
    return this.subject;
  }
}

const buckets = new Map();
class WebStorage {
  constructor(namespace, errorApi) {
    this.namespace = namespace;
    this.errorApi = errorApi;
    this.subscribers = new Set();
    this.observable = new ObservableImpl((subscriber) => {
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
  }
  static create(options) {
    var _a;
    return new WebStorage((_a = options.namespace) != null ? _a : "", options.errorApi);
  }
  get(key) {
    try {
      const storage = JSON.parse(localStorage.getItem(this.getKeyName(key)));
      return storage != null ? storage : void 0;
    } catch (e) {
      this.errorApi.post(new Error(`Error when parsing JSON config from storage for: ${key}`));
    }
    return void 0;
  }
  forBucket(name) {
    const bucketPath = `${this.namespace}/${name}`;
    if (!buckets.has(bucketPath)) {
      buckets.set(bucketPath, new WebStorage(bucketPath, this.errorApi));
    }
    return buckets.get(bucketPath);
  }
  async set(key, data) {
    localStorage.setItem(this.getKeyName(key), JSON.stringify(data, null, 2));
    this.notifyChanges({key, newValue: data});
  }
  async remove(key) {
    localStorage.removeItem(this.getKeyName(key));
    this.notifyChanges({key, newValue: void 0});
  }
  observe$(key) {
    return this.observable.filter(({key: messageKey}) => messageKey === key);
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(message) {
    for (const subscription of this.subscribers) {
      subscription.next(message);
    }
  }
}

function validateBrowserCompat() {
  if (!("localStorage" in window)) {
    throw new Error("Feature Flags are not supported on browsers without the Local Storage API");
  }
}
function validateFlagName(name) {
  if (name.length < 3) {
    throw new Error(`The '${name}' feature flag must have a minimum length of three characters.`);
  }
  if (name.length > 150) {
    throw new Error(`The '${name}' feature flag must not exceed 150 characters.`);
  }
  if (!name.match(/^[a-z]+[a-z0-9-]+$/)) {
    throw new Error(`The '${name}' feature flag must start with a lowercase letter and only contain lowercase letters, numbers and hyphens. Examples: feature-flag-one, alpha, release-2020`);
  }
}
class UserFlags extends Map {
  static load() {
    validateBrowserCompat();
    try {
      const jsonString = window.localStorage.getItem("featureFlags");
      const json = JSON.parse(jsonString);
      return new this(Object.entries(json));
    } catch (err) {
      return new this([]);
    }
  }
  get(name) {
    return super.get(name) || FeatureFlagState.Off;
  }
  set(name, state) {
    validateFlagName(name);
    const output = super.set(name, state);
    this.save();
    return output;
  }
  delete(name) {
    const output = super.delete(name);
    this.save();
    return output;
  }
  clear() {
    super.clear();
    this.save();
  }
  save() {
    window.localStorage.setItem("featureFlags", JSON.stringify(this.toObject()));
  }
  toObject() {
    return Array.from(this.entries()).reduce((obj, [key, value]) => ({...obj, [key]: value}), {});
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  toString() {
    return this.toJSON();
  }
}
class FeatureFlagsRegistry extends Array {
  static from(entries) {
    Array.from(entries).forEach((entry) => validateFlagName(entry.name));
    return new FeatureFlagsRegistry(...entries);
  }
  push(...entries) {
    Array.from(entries).forEach((entry) => validateFlagName(entry.name));
    return super.push(...entries);
  }
  concat(...entries) {
    const _concat = super.concat(...entries);
    Array.from(_concat).forEach((entry) => validateFlagName(entry.name));
    return _concat;
  }
  toObject() {
    return [...this.values()];
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  toString() {
    return this.toJSON();
  }
}
class FeatureFlags {
  constructor() {
    this.registeredFeatureFlags = [];
  }
  getFlags() {
    if (!this.userFlags)
      this.userFlags = UserFlags.load();
    return this.userFlags;
  }
  getRegisteredFlags() {
    return FeatureFlagsRegistry.from(this.registeredFeatureFlags);
  }
}

const Context$1 = createContext(void 0);
const AppContextProvider = ({app, children}) => /* @__PURE__ */ React.createElement(Context$1.Provider, {
  value: app,
  children
});
const useApp = () => {
  const app = useContext(Context$1);
  if (!app) {
    throw new Error("No app context available");
  }
  return app;
};

const defaultSystemIcons = {
  user: PersonIcon,
  group: PeopleIcon
};
const overridableSystemIcon = (key) => {
  const Component = (props) => {
    const app = useApp();
    const Icon = app.getSystemIcon(key);
    return /* @__PURE__ */ React.createElement(Icon, {
      ...props
    });
  };
  return Component;
};
const UserIcon = overridableSystemIcon("user");
const GroupIcon = overridableSystemIcon("group");

class PluginImpl {
  constructor(config) {
    this.config = config;
  }
  getId() {
    return this.config.id;
  }
  output() {
    if (this.storedOutput) {
      return this.storedOutput;
    }
    if (!this.config.register) {
      return [];
    }
    const outputs = new Array();
    this.config.register({
      router: {
        addRoute(target, component, options) {
          outputs.push({
            type: "route",
            target,
            component,
            options
          });
        },
        registerRoute(path, component, options) {
          outputs.push({type: "legacy-route", path, component, options});
        }
      },
      featureFlags: {
        register(name) {
          validateBrowserCompat();
          validateFlagName(name);
          outputs.push({type: "feature-flag", name});
        }
      }
    });
    this.storedOutput = outputs;
    return this.storedOutput;
  }
  toString() {
    return `plugin{${this.config.id}}`;
  }
}
function createPlugin(config) {
  return new PluginImpl(config);
}

class MutableRouteRef {
  constructor(config) {
    this.config = config;
    this.effectiveConfig = this.config;
  }
  override(overrideConfig) {
    this.effectiveConfig = {...this.config, ...overrideConfig};
  }
  get icon() {
    return this.effectiveConfig.icon;
  }
  get path() {
    return this.effectiveConfig.path;
  }
  get title() {
    return this.effectiveConfig.title;
  }
}
function createRouteRef(config) {
  return new MutableRouteRef(config);
}

function resolveTheme(themeId, shouldPreferDark, themes) {
  if (themeId !== void 0) {
    const selectedTheme = themes.find((theme) => theme.id === themeId);
    if (selectedTheme) {
      return selectedTheme;
    }
  }
  if (shouldPreferDark) {
    const darkTheme = themes.find((theme) => theme.variant === "dark");
    if (darkTheme) {
      return darkTheme;
    }
  }
  const lightTheme = themes.find((theme) => theme.variant === "light");
  if (lightTheme) {
    return lightTheme;
  }
  return themes[0];
}
const useShouldPreferDarkTheme = () => {
  const mediaQuery = useMemo(() => window.matchMedia("(prefers-color-scheme: dark)"), []);
  const [shouldPreferDark, setPrefersDark] = useState(mediaQuery.matches);
  useEffect(() => {
    const listener = (event) => {
      setPrefersDark(event.matches);
    };
    mediaQuery.addListener(listener);
    return () => {
      mediaQuery.removeListener(listener);
    };
  }, [mediaQuery]);
  return shouldPreferDark;
};
const AppThemeProvider = ({children}) => {
  const appThemeApi = useApi(appThemeApiRef);
  const themeId = useObservable(appThemeApi.activeThemeId$(), appThemeApi.getActiveThemeId());
  const shouldPreferDark = Boolean(window.matchMedia) ? useShouldPreferDarkTheme() : false;
  const appTheme = resolveTheme(themeId, shouldPreferDark, appThemeApi.getInstalledThemes());
  if (!appTheme) {
    throw new Error("App has no themes");
  }
  return /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme: appTheme.theme
  }, /* @__PURE__ */ React.createElement(CssBaseline, null, children));
};

class AppIdentity {
  constructor() {
    this.hasIdentity = false;
  }
  getUserId() {
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi userId before app was loaded");
    }
    return this.userId;
  }
  getProfile() {
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi profile before app was loaded");
    }
    return this.profile;
  }
  async getIdToken() {
    var _a;
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi idToken before app was loaded");
    }
    return (_a = this.idTokenFunc) == null ? void 0 : _a.call(this);
  }
  async logout() {
    var _a;
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi logoutFunc before app was loaded");
    }
    await ((_a = this.logoutFunc) == null ? void 0 : _a.call(this));
    location.reload();
  }
  setSignInResult(result) {
    if (this.hasIdentity) {
      return;
    }
    if (!result.userId) {
      throw new Error("Invalid sign-in result, userId not set");
    }
    if (!result.profile) {
      throw new Error("Invalid sign-in result, profile not set");
    }
    this.hasIdentity = true;
    this.userId = result.userId;
    this.profile = result.profile;
    this.idTokenFunc = result.getIdToken;
    this.logoutFunc = result.logout;
  }
}

function useConfigLoader(configLoader, components, appThemeApi) {
  var _a;
  const hasConfig = Boolean(configLoader);
  const config = useAsync(configLoader || (() => Promise.resolve([])));
  let noConfigNode = void 0;
  if (hasConfig && config.loading) {
    const {Progress} = components;
    noConfigNode = /* @__PURE__ */ React.createElement(Progress, null);
  } else if (config.error) {
    const {BootErrorPage} = components;
    noConfigNode = /* @__PURE__ */ React.createElement(BootErrorPage, {
      step: "load-config",
      error: config.error
    });
  }
  if (noConfigNode) {
    return {
      node: /* @__PURE__ */ React.createElement(ApiProvider, {
        apis: ApiRegistry.from([[appThemeApiRef, appThemeApi]])
      }, /* @__PURE__ */ React.createElement(AppThemeProvider, null, noConfigNode))
    };
  }
  const configReader = ConfigReader.fromConfigs((_a = config.value) != null ? _a : []);
  return {api: configReader};
}
class PrivateAppImpl {
  constructor(options) {
    this.apis = void 0;
    this.identityApi = new AppIdentity();
    this.apisOrFactory = options.apis;
    this.icons = options.icons;
    this.plugins = options.plugins;
    this.components = options.components;
    this.themes = options.themes;
    this.configLoader = options.configLoader;
  }
  getApis() {
    if (!this.apis) {
      throw new Error("Tried to access APIs before app was loaded");
    }
    return this.apis;
  }
  getPlugins() {
    return this.plugins;
  }
  getSystemIcon(key) {
    return this.icons[key];
  }
  getRoutes() {
    const routes = new Array();
    const registeredFeatureFlags = new Array();
    const {NotFoundErrorPage} = this.components;
    for (const plugin2 of this.plugins.values()) {
      for (const output of plugin2.output()) {
        switch (output.type) {
          case "legacy-route": {
            const {path, component: Component} = output;
            routes.push(/* @__PURE__ */ React.createElement(Route, {
              key: path,
              path,
              element: /* @__PURE__ */ React.createElement(Component, null)
            }));
            break;
          }
          case "route": {
            const {target, component: Component} = output;
            routes.push(/* @__PURE__ */ React.createElement(Route, {
              key: `${plugin2.getId()}-${target.path}`,
              path: target.path,
              element: /* @__PURE__ */ React.createElement(Component, null)
            }));
            break;
          }
          case "legacy-redirect-route": {
            const {path, target} = output;
            routes.push(/* @__PURE__ */ React.createElement(Navigate, {
              key: path,
              to: target
            }));
            break;
          }
          case "redirect-route": {
            const {from, to} = output;
            routes.push(/* @__PURE__ */ React.createElement(Navigate, {
              key: from.path,
              to: to.path
            }));
            break;
          }
          case "feature-flag": {
            registeredFeatureFlags.push({
              pluginId: plugin2.getId(),
              name: output.name
            });
            break;
          }
        }
      }
    }
    const FeatureFlags2 = this.apis && this.apis.get(featureFlagsApiRef);
    if (FeatureFlags2) {
      FeatureFlags2.registeredFeatureFlags = registeredFeatureFlags;
    }
    const rendered = /* @__PURE__ */ React.createElement(Routes, null, routes, /* @__PURE__ */ React.createElement(Route, {
      element: /* @__PURE__ */ React.createElement(NotFoundErrorPage, null)
    }));
    return () => rendered;
  }
  getProvider() {
    const Provider = ({children}) => {
      const appThemeApi = useMemo(() => AppThemeSelector.createWithStorage(this.themes), []);
      const loadedConfig = useConfigLoader(this.configLoader, this.components, appThemeApi);
      if ("node" in loadedConfig) {
        return loadedConfig.node;
      }
      const configApi = loadedConfig.api;
      const appApis = ApiRegistry.from([
        [appThemeApiRef, appThemeApi],
        [configApiRef, configApi],
        [identityApiRef, this.identityApi]
      ]);
      if (!this.apis) {
        if ("get" in this.apisOrFactory) {
          this.apis = this.apisOrFactory;
        } else {
          this.apis = this.apisOrFactory(configApi);
        }
      }
      const apis2 = new ApiAggregator(this.apis, appApis);
      return /* @__PURE__ */ React.createElement(ApiProvider, {
        apis: apis2
      }, /* @__PURE__ */ React.createElement(AppContextProvider, {
        app: this
      }, /* @__PURE__ */ React.createElement(AppThemeProvider, null, children)));
    };
    return Provider;
  }
  getRouter() {
    const {
      Router: RouterComponent,
      SignInPage: SignInPageComponent
    } = this.components;
    const SignInPageWrapper = ({component: Component, children}) => {
      const [result, setResult] = useState();
      if (result) {
        this.identityApi.setSignInResult(result);
        return children;
      }
      return /* @__PURE__ */ React.createElement(Component, {
        onResult: setResult
      });
    };
    const AppRouter = ({children}) => {
      var _a;
      const configApi = useApi(configApiRef);
      let {pathname} = new URL((_a = configApi.getOptionalString("app.baseUrl")) != null ? _a : "/", "http://dummy.dev");
      if (pathname.endsWith("/")) {
        pathname = pathname.replace(/\/$/, "");
      }
      if (!SignInPageComponent) {
        this.identityApi.setSignInResult({
          userId: "guest",
          profile: {
            email: "guest@example.com",
            displayName: "Guest"
          }
        });
        return /* @__PURE__ */ React.createElement(RouterComponent, null, /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
          path: `${pathname}/*`,
          element: /* @__PURE__ */ React.createElement(React.Fragment, null, children)
        })));
      }
      return /* @__PURE__ */ React.createElement(RouterComponent, null, /* @__PURE__ */ React.createElement(SignInPageWrapper, {
        component: SignInPageComponent
      }, /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
        path: `${pathname}/*`,
        element: /* @__PURE__ */ React.createElement(React.Fragment, null, children)
      }))));
    };
    return AppRouter;
  }
  verify() {
    const pluginIds = new Set();
    for (const plugin2 of this.plugins) {
      const id = plugin2.getId();
      if (pluginIds.has(id)) {
        throw new Error(`Duplicate plugin found '${id}'`);
      }
      pluginIds.add(id);
    }
  }
}

var privateExports = /*#__PURE__*/Object.freeze({
  __proto__: null,
  PrivateAppImpl: PrivateAppImpl
});

export default privateExports;
export { AlertApiForwarder, ApiProvider, ApiRegistry, ApiTestRegistry, AppThemeSelector, ErrorAlerter, ErrorApiForwarder, FeatureFlagState, FeatureFlags, GithubAuth, GitlabAuth, GoogleAuth, GroupIcon, OAuth2, OAuthRequestManager, OktaAuth, SessionState, UserIcon, WebStorage, alertApiRef, appThemeApiRef, configApiRef, createApiFactory, createApiRef, createPlugin, createRouteRef, defaultSystemIcons, errorApiRef, featureFlagsApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, oauth2ApiRef, oauthRequestApiRef, oktaAuthApiRef, storageApiRef, useApi, useApiHolder, useApp };
