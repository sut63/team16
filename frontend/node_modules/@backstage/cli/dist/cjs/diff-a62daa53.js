'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('commander');
require('chalk');
var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
require('path');
require('inquirer');
require('handlebars');
require('recursive-readdir');
require('diff');
var read = require('./read-de0d3f6f.js');

const fileHandlers = [
  {
    patterns: ["package.json"],
    handler: read.handlers.packageJson
  },
  {
    patterns: ["tsconfig.json"],
    handler: read.handlers.exactMatch
  },
  {
    patterns: [".eslintrc.js", /^(src|dev)\/[^/]+$/],
    handler: read.handlers.exists
  },
  {
    patterns: ["README.md", /^src\//],
    handler: read.handlers.skip
  }
];
var diff = async (cmd) => {
  let promptFunc = read.inquirerPromptFunc;
  let finalize = () => {
  };
  if (cmd.check) {
    [promptFunc, finalize] = read.makeCheckPromptFunc();
  } else if (cmd.yes) {
    promptFunc = read.yesPromptFunc;
  }
  const data = await readPluginData();
  const templateFiles = await read.diffTemplateFiles("default-plugin", {
    version: index.version,
    ...data
  });
  await read.handleAllFiles(fileHandlers, templateFiles, promptFunc);
  await finalize();
};
async function readPluginData() {
  let name;
  try {
    const pkg = require(index.paths.resolveTarget("package.json"));
    name = pkg.name;
  } catch (error) {
    throw new Error(`Failed to read target package, ${error}`);
  }
  const pluginTsContents = await fs.readFile(index.paths.resolveTarget("src/plugin.ts"), "utf8");
  const pluginIdMatch = pluginTsContents.match(/id: ['"`](.+?)['"`]/);
  if (!pluginIdMatch) {
    throw new Error(`Failed to parse plugin.ts, no plugin ID found`);
  }
  const id = pluginIdMatch[1];
  return {id, name};
}

exports.default = diff;
