'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('commander');
var chalk2 = _interopDefault(require('chalk'));
var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var util = require('util');
var inquirer2 = _interopDefault(require('inquirer'));
var child_process = require('child_process');
var os2 = require('os');
var os2__default = _interopDefault(os2);
require('handlebars');
require('ora');
require('recursive-readdir');
var tasks = require('./tasks-79e59c50.js');
var codeowners = require('./codeowners-3ceadfb3.js');

const exec = util.promisify(child_process.exec);
async function checkExists(rootDir, id) {
  await tasks.Task.forItem("checking", id, async () => {
    const destination = path2.resolve(rootDir, "plugins", id);
    if (await fs.pathExists(destination)) {
      const existing = chalk2.cyan(destination.replace(`${rootDir}/`, ""));
      throw new Error(`A plugin with the same name already exists: ${existing}
Please try again with a different plugin ID`);
    }
  });
}
async function createTemporaryPluginFolder(tempDir) {
  await tasks.Task.forItem("creating", "temporary directory", async () => {
    try {
      await fs.mkdir(tempDir);
    } catch (error) {
      throw new Error(`Failed to create temporary plugin directory: ${error.message}`);
    }
  });
}
const sortObjectByKeys = (obj) => {
  return Object.keys(obj).sort().reduce((result, key) => {
    result[key] = obj[key];
    return result;
  }, {});
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const addExportStatement = async (file, exportStatement) => {
  const newContents = fs.readFileSync(file, "utf8").split("\n").filter(Boolean).concat([exportStatement]).concat([""]).join("\n");
  await fs.writeFile(file, newContents, "utf8");
};
async function addPluginDependencyToApp(rootDir, pluginName, versionStr) {
  const pluginPackage = `@backstage/plugin-${pluginName}`;
  const packageFilePath = "packages/app/package.json";
  const packageFile = path2.resolve(rootDir, packageFilePath);
  await tasks.Task.forItem("processing", packageFilePath, async () => {
    const packageFileContent = await fs.readFile(packageFile, "utf-8");
    const packageFileJson = JSON.parse(packageFileContent);
    const dependencies = packageFileJson.dependencies;
    if (dependencies[pluginPackage]) {
      throw new Error(`Plugin ${pluginPackage} already exists in ${packageFile}`);
    }
    dependencies[pluginPackage] = `^${versionStr}`;
    packageFileJson.dependencies = sortObjectByKeys(dependencies);
    const newContents = `${JSON.stringify(packageFileJson, null, 2)}
`;
    await fs.writeFile(packageFile, newContents, "utf-8").catch((error) => {
      throw new Error(`Failed to add plugin as dependency to app: ${packageFile}: ${error.message}`);
    });
  });
}
async function addPluginToApp(rootDir, pluginName) {
  const pluginPackage = `@backstage/plugin-${pluginName}`;
  const pluginNameCapitalized = pluginName.split("-").map((name) => capitalize(name)).join("");
  const pluginExport = `export { plugin as ${pluginNameCapitalized} } from '${pluginPackage}';`;
  const pluginsFilePath = "packages/app/src/plugins.ts";
  const pluginsFile = path2.resolve(rootDir, pluginsFilePath);
  await tasks.Task.forItem("processing", pluginsFilePath, async () => {
    await addExportStatement(pluginsFile, pluginExport).catch((error) => {
      throw new Error(`Failed to import plugin in app: ${pluginsFile}: ${error.message}`);
    });
  });
}
async function cleanUp(tempDir) {
  await tasks.Task.forItem("remove", "temporary directory", async () => {
    await fs.remove(tempDir);
  });
}
async function buildPlugin(pluginFolder) {
  const commands = ["yarn install", "yarn tsc", "yarn build"];
  for (const command of commands) {
    await tasks.Task.forItem("executing", command, async () => {
      process.chdir(pluginFolder);
      await exec(command).catch((error) => {
        process.stdout.write(error.stderr);
        process.stdout.write(error.stdout);
        throw new Error(`Could not execute command ${chalk2.cyan(command)}`);
      });
    });
  }
}
async function movePlugin(tempDir, destination, id) {
  await tasks.Task.forItem("moving", id, async () => {
    await fs.move(tempDir, destination).catch((error) => {
      throw new Error(`Failed to move plugin from ${tempDir} to ${destination}: ${error.message}`);
    });
  });
}
var createPlugin = async () => {
  const codeownersPath = await codeowners.getCodeownersFilePath(index.paths.targetRoot);
  const questions = [
    {
      type: "input",
      name: "id",
      message: chalk2.blue("Enter an ID for the plugin [required]"),
      validate: (value) => {
        if (!value) {
          return chalk2.red("Please enter an ID for the plugin");
        } else if (!/^[a-z0-9]+(-[a-z0-9]+)*$/.test(value)) {
          return chalk2.red("Plugin IDs must be kebab-cased and contain only letters, digits, and dashes.");
        }
        return true;
      }
    }
  ];
  if (codeownersPath) {
    questions.push({
      type: "input",
      name: "owner",
      message: chalk2.blue("Enter the owner(s) of the plugin. If specified, this will be added to CODEOWNERS for the plugin path. [optional]"),
      validate: (value) => {
        if (!value) {
          return true;
        }
        const ownerIds2 = codeowners.parseOwnerIds(value);
        if (!ownerIds2) {
          return chalk2.red("The owner must be a space separated list of team names (e.g. @org/team-name), usernames (e.g. @username), or the email addresses of users (e.g. user@example.com).");
        }
        return true;
      }
    });
  }
  const answers = await inquirer2.prompt(questions);
  const appPackage = index.paths.resolveTargetRoot("packages/app");
  const templateDir = index.paths.resolveOwn("templates/default-plugin");
  const tempDir = path2.resolve(os2__default.tmpdir(), answers.id);
  const pluginDir = index.paths.resolveTargetRoot("plugins", answers.id);
  const ownerIds = codeowners.parseOwnerIds(answers.owner);
  tasks.Task.log();
  tasks.Task.log("Creating the plugin...");
  try {
    tasks.Task.section("Checking if the plugin ID is available");
    await checkExists(index.paths.targetRoot, answers.id);
    tasks.Task.section("Creating a temporary plugin directory");
    await createTemporaryPluginFolder(tempDir);
    tasks.Task.section("Preparing files");
    await tasks.templatingTask(templateDir, tempDir, {...answers, version: index.version});
    tasks.Task.section("Moving to final location");
    await movePlugin(tempDir, pluginDir, answers.id);
    tasks.Task.section("Building the plugin");
    await buildPlugin(pluginDir);
    if (await fs.pathExists(appPackage)) {
      tasks.Task.section("Adding plugin as dependency in app");
      await addPluginDependencyToApp(index.paths.targetRoot, answers.id, index.version);
      tasks.Task.section("Import plugin in app");
      await addPluginToApp(index.paths.targetRoot, answers.id);
    }
    if (ownerIds && ownerIds.length) {
      await codeowners.addCodeownersEntry(codeownersPath, `/plugins/${answers.id}`, ownerIds);
    }
    tasks.Task.log();
    tasks.Task.log(`ðŸ¥‡  Successfully created ${chalk2.cyan(`@backstage/plugin-${answers.id}`)}`);
    tasks.Task.log();
    tasks.Task.exit();
  } catch (error) {
    tasks.Task.error(error.message);
    tasks.Task.log("It seems that something went wrong when creating the plugin ðŸ¤”");
    tasks.Task.log("We are going to clean up, and then you can try again.");
    tasks.Task.section("Cleanup");
    await cleanUp(tempDir);
    tasks.Task.error("ðŸ”¥  Failed to create plugin!");
    tasks.Task.exit(1);
  }
};

exports.addExportStatement = addExportStatement;
exports.addPluginDependencyToApp = addPluginDependencyToApp;
exports.addPluginToApp = addPluginToApp;
exports.capitalize = capitalize;
exports.createTemporaryPluginFolder = createTemporaryPluginFolder;
exports.default = createPlugin;
exports.movePlugin = movePlugin;
