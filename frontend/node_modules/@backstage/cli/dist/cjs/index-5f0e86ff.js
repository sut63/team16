'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var os2 = require('os');
var os2__default = _interopDefault(os2);
var run = require('./run-c730dc1d.js');
var tar2 = _interopDefault(require('tar'));

async function createDistWorkspace(packageNames, options = {}) {
  var _a, _b;
  const targetDir = (_a = options.targetDir) != null ? _a : await fs.mkdtemp(path2.resolve(os2.tmpdir(), "dist-workspace"));
  const targets = await findTargetPackages(packageNames);
  await moveToDistWorkspace(targetDir, targets);
  const files = (_b = options.files) != null ? _b : ["yarn.lock", "package.json"];
  for (const file of files) {
    const src = typeof file === "string" ? file : file.src;
    const dest = typeof file === "string" ? file : file.dest;
    await fs.copy(index.paths.resolveTargetRoot(src), path2.resolve(targetDir, dest));
  }
  return targetDir;
}
async function moveToDistWorkspace(workspaceDir, localPackages) {
  await Promise.all(localPackages.map(async (target, index$1) => {
    console.log(`Repacking ${target.name} into dist workspace`);
    const archive = `temp-package-${index$1}.tgz`;
    const archivePath = path2.resolve(workspaceDir, archive);
    await run.run("yarn", ["pack", "--filename", archivePath], {
      cwd: target.location
    });
    if (target.scripts.postpack) {
      await run.run("yarn", ["postpack"], {cwd: target.location});
    }
    const outputDir = path2.relative(index.paths.targetRoot, target.location);
    const absoluteOutputPath = path2.resolve(workspaceDir, outputDir);
    await fs.ensureDir(absoluteOutputPath);
    await tar2.extract({
      file: archivePath,
      cwd: absoluteOutputPath,
      strip: 1
    });
    await fs.remove(archivePath);
  }));
}
async function findTargetPackages(pkgNames) {
  const LernaProject = require("@lerna/project");
  const PackageGraph = require("@lerna/package-graph");
  const project = new LernaProject(index.paths.targetDir);
  const packages = await project.getPackages();
  const graph = new PackageGraph(packages);
  const targets = new Map();
  const searchNames = pkgNames.slice();
  while (searchNames.length) {
    const name = searchNames.pop();
    if (targets.has(name)) {
      continue;
    }
    const node = graph.get(name);
    if (!node) {
      throw new Error(`Package '${name}' not found`);
    }
    const pkgDeps = Object.keys(node.pkg.dependencies);
    const localDeps = Array.from(node.localDependencies.keys());
    const filteredDeps = localDeps.filter((dep) => pkgDeps.includes(dep));
    searchNames.push(...filteredDeps);
    targets.set(name, node.pkg);
  }
  return Array.from(targets.values());
}

exports.createDistWorkspace = createDistWorkspace;
