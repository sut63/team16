'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk2 = _interopDefault(require('chalk'));
var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var svgrTemplate = require('./svgrTemplate-2930b0e1.js');
var rollup = require('rollup');
var peerDepsExternal = _interopDefault(require('rollup-plugin-peer-deps-external'));
var commonjs = _interopDefault(require('@rollup/plugin-commonjs'));
var resolve = _interopDefault(require('@rollup/plugin-node-resolve'));
var postcss = _interopDefault(require('rollup-plugin-postcss'));
var esbuild = _interopDefault(require('rollup-plugin-esbuild'));
var imageFiles = _interopDefault(require('rollup-plugin-image-files'));
var svgr = _interopDefault(require('@svgr/rollup'));
var dts = _interopDefault(require('rollup-plugin-dts'));
var json = _interopDefault(require('@rollup/plugin-json'));

(function(Output2) {
  Output2[Output2["esm"] = 0] = "esm";
  Output2[Output2["cjs"] = 1] = "cjs";
  Output2[Output2["types"] = 2] = "types";
})(exports.Output || (exports.Output = {}));

const makeConfigs = async (options) => {
  const typesInput = index.paths.resolveTargetRoot("dist", path2.relative(index.paths.targetRoot, index.paths.targetDir), "src/index.d.ts");
  const declarationsExist = await fs.pathExists(typesInput);
  if (!declarationsExist) {
    const path2$1 = path2.relative(index.paths.targetDir, typesInput);
    throw new Error(`No declaration files found at ${path2$1}, be sure to run ${chalk2.bgRed.white("yarn tsc")} to generate .d.ts files before packaging`);
  }
  const configs = new Array();
  if (options.outputs.has(exports.Output.cjs) || options.outputs.has(exports.Output.esm)) {
    const output = new Array();
    const mainFields = ["module", "main"];
    if (options.outputs.has(exports.Output.cjs)) {
      output.push({
        dir: "dist",
        entryFileNames: "index.cjs.js",
        chunkFileNames: "cjs/[name]-[hash].js",
        format: "commonjs"
      });
    }
    if (options.outputs.has(exports.Output.esm)) {
      output.push({
        dir: "dist",
        entryFileNames: "index.esm.js",
        chunkFileNames: "esm/[name]-[hash].js",
        format: "module"
      });
      mainFields.unshift("browser");
    }
    configs.push({
      input: "src/index.ts",
      output,
      preserveEntrySignatures: "strict",
      external: require("module").builtinModules,
      plugins: [
        peerDepsExternal({
          includeDependencies: true
        }),
        resolve({mainFields}),
        commonjs({
          include: ["node_modules/**", "../../node_modules/**"],
          exclude: ["**/*.stories.*", "**/*.test.*"]
        }),
        postcss(),
        imageFiles({exclude: "**/*.icon.svg"}),
        json(),
        svgr({
          include: "**/*.icon.svg",
          template: svgrTemplate.svgrTemplate
        }),
        esbuild({
          target: "es2019"
        })
      ]
    });
  }
  if (options.outputs.has(exports.Output.types)) {
    configs.push({
      input: typesInput,
      output: {
        file: "dist/index.d.ts",
        format: "es"
      },
      plugins: [dts()]
    });
  }
  return configs;
};

function formatErrorMessage(error) {
  let msg = "";
  if (error.code === "PLUGIN_ERROR") {
    if (error.plugin === "esbuild") {
      msg += `${error.message}

`;
      for (const {text, location} of error.errors) {
        const {line, column} = location;
        const path2$1 = path2.relative(index.paths.targetDir, error.id);
        const loc = chalk2.cyan(`${path2$1}:${line}:${column}`);
        if (text === 'Unexpected "<"' && error.id.endsWith(".js")) {
          msg += `${loc}: ${text}, JavaScript files with JSX should use a .jsx extension`;
        } else {
          msg += `${loc}: ${text}`;
        }
      }
    } else {
      msg += `(plugin ${error.plugin}) ${error}
`;
    }
  } else {
    if (error.loc) {
      const file = `${index.paths.resolveTarget(error.loc.file || error.id)}`;
      const pos = `${error.loc.line}:${error.loc.column}`;
      msg += `${file} [${pos}]
`;
    } else if (error.id) {
      msg += `${index.paths.resolveTarget(error.id)}
`;
    }
    msg += `${error}
`;
    if (error.url) {
      msg += `${chalk2.cyan(error.url)}
`;
    }
    if (error.frame) {
      msg += `${chalk2.dim(error.frame)}
`;
    }
  }
  return msg;
}
async function build(config2) {
  try {
    const bundle = await rollup.rollup(config2);
    if (config2.output) {
      for (const output of [config2.output].flat()) {
        await bundle.generate(output);
        await bundle.write(output);
      }
    }
  } catch (error) {
    throw new Error(formatErrorMessage(error));
  }
}
const buildPackage = async (options) => {
  const configs = await makeConfigs(options);
  await fs.remove(index.paths.resolveTarget("dist"));
  await Promise.all(configs.map(build));
};

exports.buildPackage = buildPackage;
