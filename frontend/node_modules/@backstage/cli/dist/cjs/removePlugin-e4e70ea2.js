'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('commander');
var chalk2 = _interopDefault(require('chalk'));
var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var inquirer2 = _interopDefault(require('inquirer'));
require('handlebars');
require('ora');
require('recursive-readdir');
var tasks = require('./tasks-79e59c50.js');
var codeowners = require('./codeowners-3ceadfb3.js');

const BACKSTAGE = "@backstage";
const checkExists = async (rootDir, pluginName) => {
  await tasks.Task.forItem("checking", pluginName, async () => {
    try {
      const destination = path2__default.join(rootDir, "plugins", pluginName);
      const pathExist = await fs.pathExists(destination);
      if (!pathExist) {
        throw new Error(chalk2.red(`   Plugin ${chalk2.cyan(pluginName)} does not exist!`));
      }
    } catch (e) {
      throw new Error(chalk2.red(`   There was an error removing plugin ${chalk2.cyan(pluginName)}: ${e.message}`));
    }
  });
};
const removePluginDirectory = async (destination) => {
  await tasks.Task.forItem("removing", "plugin files", async () => {
    try {
      await fs.remove(destination);
    } catch (e) {
      throw Error(chalk2.red(`   There was a problem removing the plugin directory: ${e.message}`));
    }
  });
};
const removeSymLink = async (destination) => {
  await tasks.Task.forItem("removing", "symbolic link", async () => {
    const symLinkExists = fs.pathExists(destination);
    if (symLinkExists) {
      try {
        await fs.remove(destination);
      } catch (e) {
        throw Error(chalk2.red(`   Could not remove symbolic link	${chalk2.cyan(destination)}: ${e.message}`));
      }
    }
  });
};
const removeAllStatementsContainingID = async (file, ID) => {
  const originalContent = await fs.readFile(file, "utf8");
  const contentAfterRemoval = originalContent.split("\n").filter((statement) => !statement.includes(`${ID}`)).join("\n");
  if (originalContent !== contentAfterRemoval) {
    await fs.writeFile(file, contentAfterRemoval, "utf8");
  }
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const removeReferencesFromPluginsFile = async (pluginsFile, pluginName) => {
  const pluginNameCapitalized = pluginName.split("-").map((name) => capitalize(name)).join("");
  await tasks.Task.forItem("removing", "export references", async () => {
    try {
      await removeAllStatementsContainingID(pluginsFile, pluginNameCapitalized);
    } catch (e) {
      throw new Error(chalk2.red(`   There was an error removing export statement for plugin ${chalk2.cyan(pluginNameCapitalized)}: ${e.message}`));
    }
  });
};
const removePluginFromCodeOwners = async (codeOwnersFile, pluginName) => {
  await tasks.Task.forItem("removing", "codeowners references", async () => {
    try {
      await removeAllStatementsContainingID(codeOwnersFile, pluginName);
    } catch (e) {
      throw new Error(chalk2.red(`   There was an error removing code owners statement for plugin ${chalk2.cyan(pluginName)}: ${e.message}`));
    }
  });
};
const removeReferencesFromAppPackage = async (appPackageFile, pluginName) => {
  const pluginPackage = `${BACKSTAGE}/plugin-${pluginName}`;
  await tasks.Task.forItem("removing", "plugin app dependency", async () => {
    try {
      const appPackageFileContent = await fs.readFile(appPackageFile, "utf-8");
      const appPackageFileContentJSON = JSON.parse(appPackageFileContent);
      const dependencies = appPackageFileContentJSON.dependencies;
      if (!dependencies[pluginPackage]) {
        throw new Error(chalk2.red(` Plugin ${chalk2.cyan(pluginPackage)} does not exist in ${chalk2.cyan(appPackageFile)}`));
      }
      delete dependencies[pluginPackage];
      await fs.writeFile(appPackageFile, `${JSON.stringify(appPackageFileContentJSON, null, 2)}
`, "utf-8");
    } catch (e) {
      throw new Error(chalk2.red(`  Failed to remove plugin as dependency in app: ${chalk2.cyan(appPackageFile)}: ${e.message}`));
    }
  });
};
var removePlugin = async () => {
  const questions = [
    {
      type: "input",
      name: "pluginName",
      message: chalk2.blue("Enter the ID of the plugin to be removed [required]"),
      validate: (value) => {
        if (!value) {
          return chalk2.red("Please enter an ID for the plugin");
        } else if (!/^[a-z0-9]+(-[a-z0-9]+)*$/.test(value)) {
          return chalk2.red("Plugin IDs must be kehbab-cased and contain only letters, digits and dashes.");
        }
        return true;
      }
    }
  ];
  const answers = await inquirer2.prompt(questions);
  const pluginName = answers.pluginName;
  const appPackage = index.paths.resolveTargetRoot("packages/app");
  const pluginDir = index.paths.resolveTargetRoot("plugins", answers.pluginName);
  const codeOwnersFile = await codeowners.getCodeownersFilePath(index.paths.targetRoot);
  const appPackageFile = path2__default.join(appPackage, "package.json");
  const appPluginsFile = path2__default.join(appPackage, "src", "plugins.ts");
  const pluginScopedDirectory = index.paths.resolveTargetRoot("node_modules", BACKSTAGE, `plugin-${pluginName}`);
  tasks.Task.log();
  tasks.Task.log("Removing the plugin...");
  console.log(pluginScopedDirectory);
  try {
    tasks.Task.section("Checking the plugin exists.");
    await checkExists(index.paths.targetRoot, pluginName);
    tasks.Task.section("Removing plugin files.");
    await removePluginDirectory(pluginDir);
    tasks.Task.section("Removing symbolic link from @backstage.");
    await removeSymLink(pluginScopedDirectory);
    if (await fs.pathExists(appPackage)) {
      tasks.Task.section("Removing references from plugins.ts.");
      await removeReferencesFromPluginsFile(appPluginsFile, pluginName);
      tasks.Task.section("Removing plugin dependency from app.");
      await removeReferencesFromAppPackage(appPackageFile, pluginName);
    }
    if (codeOwnersFile) {
      tasks.Task.section("Removing codeowners reference.");
      await removePluginFromCodeOwners(codeOwnersFile, pluginName);
    }
    tasks.Task.log();
    tasks.Task.log(`ðŸ¥‡  Successfully removed ${chalk2.cyan(`@backstage/plugin-${answers.id}`)}`);
    tasks.Task.log();
  } catch (error) {
    tasks.Task.error(error.message);
    tasks.Task.log("It seems that something went wrong when removing the plugin ðŸ¤”");
  }
};

exports.checkExists = checkExists;
exports.default = removePlugin;
exports.removePluginDirectory = removePluginDirectory;
exports.removePluginFromCodeOwners = removePluginFromCodeOwners;
exports.removeReferencesFromAppPackage = removeReferencesFromAppPackage;
exports.removeReferencesFromPluginsFile = removeReferencesFromPluginsFile;
exports.removeSymLink = removeSymLink;
