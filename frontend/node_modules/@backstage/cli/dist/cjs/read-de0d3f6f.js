'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk2 = _interopDefault(require('chalk'));
var index = require('./index-efc4b836.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var inquirer2 = _interopDefault(require('inquirer'));
var handlebars2 = _interopDefault(require('handlebars'));
var recursive = _interopDefault(require('recursive-readdir'));
var diff$1 = require('diff');

class PackageJsonHandler {
  constructor(writeFunc, prompt, pkg, targetPkg, variant) {
    this.writeFunc = writeFunc;
    this.prompt = prompt;
    this.pkg = pkg;
    this.targetPkg = targetPkg;
    this.variant = variant;
  }
  static async handler({path, write, missing, targetContents, templateContents}, prompt, variant) {
    console.log("Checking package.json");
    if (missing) {
      throw new Error(`${path} doesn't exist`);
    }
    const pkg = JSON.parse(templateContents);
    const targetPkg = JSON.parse(targetContents);
    const handler = new PackageJsonHandler(write, prompt, pkg, targetPkg, variant);
    await handler.handle();
  }
  static async appHandler(file, prompt) {
    return PackageJsonHandler.handler(file, prompt, "app");
  }
  async handle() {
    await this.syncField("main");
    if (this.variant !== "app") {
      await this.syncField("main:src");
    }
    await this.syncField("types");
    await this.syncField("files");
    await this.syncScripts();
    await this.syncPublishConfig();
    await this.syncDependencies("dependencies");
    await this.syncDependencies("devDependencies");
  }
  async syncField(fieldName, obj = this.pkg, targetObj = this.targetPkg, prefix) {
    const fullFieldName = chalk2.cyan(prefix ? `${prefix}[${fieldName}]` : fieldName);
    const newValue = obj[fieldName];
    const coloredNewValue = chalk2.cyan(JSON.stringify(newValue));
    if (fieldName in targetObj) {
      const oldValue = targetObj[fieldName];
      if (JSON.stringify(oldValue) === JSON.stringify(newValue)) {
        return;
      }
      const coloredOldValue = chalk2.cyan(JSON.stringify(oldValue));
      const msg = `package.json has mismatched field, ${fullFieldName}, change from ${coloredOldValue} to ${coloredNewValue}?`;
      if (await this.prompt(msg)) {
        targetObj[fieldName] = newValue;
        await this.write();
      }
    } else if (fieldName in obj) {
      if (await this.prompt(`package.json is missing field ${fullFieldName}, set to ${coloredNewValue}?`)) {
        targetObj[fieldName] = newValue;
        await this.write();
      }
    }
  }
  async syncScripts() {
    const pkgScripts = this.pkg.scripts;
    const targetScripts = this.targetPkg.scripts = this.targetPkg.scripts || {};
    if (!pkgScripts) {
      return;
    }
    for (const key of Object.keys(pkgScripts)) {
      await this.syncField(key, pkgScripts, targetScripts, "scripts");
    }
  }
  async syncPublishConfig() {
    const pkgPublishConf = this.pkg.publishConfig;
    const targetPublishConf = this.targetPkg.publishConfig;
    if (!pkgPublishConf) {
      return;
    }
    if (!targetPublishConf) {
      if (await this.prompt("Missing publishConfig, do you want to add it?")) {
        this.targetPkg.publishConfig = pkgPublishConf;
        await this.write();
      }
      return;
    }
    for (const key of Object.keys(pkgPublishConf)) {
      if (!["access", "registry"].includes(key)) {
        await this.syncField(key, pkgPublishConf, targetPublishConf, "publishConfig");
      }
    }
  }
  async syncDependencies(fieldName) {
    const pkgDeps = this.pkg[fieldName];
    const targetDeps = this.targetPkg[fieldName] = this.targetPkg[fieldName] || {};
    if (!pkgDeps) {
      return;
    }
    for (const key of Object.keys(pkgDeps)) {
      if (this.variant === "app" && key.startsWith("plugin-")) {
        continue;
      }
      await this.syncField(key, pkgDeps, targetDeps, fieldName);
    }
  }
  async write() {
    await this.writeFunc(`${JSON.stringify(this.targetPkg, null, 2)}
`);
  }
}
async function exactMatchHandler({path, write, missing, targetContents, templateContents}, prompt) {
  console.log(`Checking ${path}`);
  const coloredPath = chalk2.cyan(path);
  if (missing) {
    if (await prompt(`Missing ${coloredPath}, do you want to add it?`)) {
      await write(templateContents);
    }
    return;
  }
  if (targetContents === templateContents) {
    return;
  }
  const diffs = diff$1.diffLines(targetContents, templateContents);
  for (const diff2 of diffs) {
    if (diff2.added) {
      process.stdout.write(chalk2.green(`+${diff2.value}`));
    } else if (diff2.removed) {
      process.stdout.write(chalk2.red(`-${diff2.value}`));
    } else {
      process.stdout.write(` ${diff2.value}`);
    }
  }
  if (await prompt(`Outdated ${coloredPath}, do you want to apply the above patch?`)) {
    await write(templateContents);
  }
}
async function existsHandler({path, write, missing, templateContents}, prompt) {
  console.log(`Making sure ${path} exists`);
  const coloredPath = chalk2.cyan(path);
  if (missing) {
    if (await prompt(`Missing ${coloredPath}, do you want to add it?`)) {
      await write(templateContents);
    }
    return;
  }
}
async function skipHandler({path}) {
  console.log(`Skipping ${path}`);
}
const handlers = {
  skip: skipHandler,
  exists: existsHandler,
  exactMatch: exactMatchHandler,
  packageJson: PackageJsonHandler.handler,
  appPackageJson: PackageJsonHandler.appHandler
};
async function handleAllFiles(fileHandlers, files, promptFunc) {
  for (const file of files) {
    const {path} = file;
    const fileHandler = fileHandlers.find((handler) => handler.patterns.some((pattern) => typeof pattern === "string" ? pattern === path : pattern.test(path)));
    if (fileHandler) {
      await fileHandler.handler(file, promptFunc);
    } else {
      throw new Error(`No template file handler found for ${path}`);
    }
  }
}

const inquirerPromptFunc = async (msg) => {
  const {result} = await inquirer2.prompt({
    type: "confirm",
    name: "result",
    message: chalk2.blue(msg)
  });
  return result;
};
const makeCheckPromptFunc = () => {
  let failed = false;
  const promptFunc = async (msg) => {
    failed = true;
    console.log(chalk2.red(`[Check Failed] ${msg}`));
    return false;
  };
  const finalize = () => {
    if (failed) {
      throw new Error("Check failed, the plugin is not in sync with the latest template");
    }
  };
  return [promptFunc, finalize];
};
const yesPromptFunc = async (msg) => {
  console.log(`Accepting: "${msg}"`);
  return true;
};

async function readTemplateFile(templateFile, templateVars) {
  const contents = await fs.readFile(templateFile, "utf8");
  if (!templateFile.endsWith(".hbs")) {
    return contents;
  }
  return handlebars2.compile(contents)(templateVars);
}
async function readTemplate(templateDir, templateVars) {
  const templateFilePaths = await recursive(templateDir).catch((error) => {
    throw new Error(`Failed to read template directory: ${error.message}`);
  });
  const templatedFiles = new Array();
  for (const templateFile of templateFilePaths) {
    const path2$1 = path2.relative(templateDir, templateFile).replace(/\.hbs$/, "");
    const contents = await readTemplateFile(templateFile, templateVars);
    templatedFiles.push({path: path2$1, contents});
  }
  return templatedFiles;
}
async function diffTemplatedFiles(targetDir, templatedFiles) {
  const fileDiffs = new Array();
  for (const {path: path2$1, contents: templateContents} of templatedFiles) {
    const targetPath = path2.resolve(targetDir, path2$1);
    const targetExists = await fs.pathExists(targetPath);
    const write = async (contents) => {
      await fs.ensureDir(path2.dirname(targetPath));
      await fs.writeFile(targetPath, contents, "utf8");
    };
    if (targetExists) {
      const targetContents = await fs.readFile(targetPath, "utf8");
      fileDiffs.push({
        path: path2$1,
        write,
        missing: false,
        targetContents,
        templateContents
      });
    } else {
      fileDiffs.push({
        path: path2$1,
        write,
        missing: true,
        targetContents: "",
        templateContents
      });
    }
  }
  return fileDiffs;
}
async function diffTemplateFiles(template, templateData) {
  const templateDir = index.paths.resolveOwn("templates", template);
  const templatedFiles = await readTemplate(templateDir, templateData);
  const fileDiffs = await diffTemplatedFiles(index.paths.targetDir, templatedFiles);
  return fileDiffs;
}

exports.diffTemplateFiles = diffTemplateFiles;
exports.handleAllFiles = handleAllFiles;
exports.handlers = handlers;
exports.inquirerPromptFunc = inquirerPromptFunc;
exports.makeCheckPromptFunc = makeCheckPromptFunc;
exports.yesPromptFunc = yesPromptFunc;
