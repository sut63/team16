'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk2 = _interopDefault(require('chalk'));
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var webpack2 = _interopDefault(require('webpack'));
var paths = require('./paths-5bdff86a.js');
var yn2 = _interopDefault(require('yn'));
var FileSizeReporter = require('react-dev-utils/FileSizeReporter');
var formatWebpackMessages2 = _interopDefault(require('react-dev-utils/formatWebpackMessages'));

const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
async function buildBundle(options) {
  const {statsJsonEnabled} = options;
  const paths2 = paths.resolveBundlingPaths(options);
  const config2 = paths.createConfig(paths2, {
    ...options,
    checksEnabled: false,
    isDev: false,
    baseUrl: paths.resolveBaseUrl(options.config)
  });
  const compiler = webpack2(config2);
  const isCi = yn2(process.env.CI, {default: false});
  const previousFileSizes = await FileSizeReporter.measureFileSizesBeforeBuild(paths2.targetDist);
  await fs.emptyDir(paths2.targetDist);
  if (paths2.targetPublic) {
    await fs.copy(paths2.targetPublic, paths2.targetDist, {
      dereference: true,
      filter: (file) => file !== paths2.targetHtml
    });
  }
  const {stats} = await build(compiler, isCi).catch((error) => {
    console.log(chalk2.red("Failed to compile.\n"));
    throw new Error(`Failed to compile.
${error.message || error}`);
  });
  if (statsJsonEnabled) {
    await require("bfj").write(path2.resolve(paths2.targetDist, "bundle-stats.json"), stats.toJson());
  }
  FileSizeReporter.printFileSizesAfterBuild(stats, previousFileSizes, paths2.targetDist, WARN_AFTER_BUNDLE_GZIP_SIZE, WARN_AFTER_CHUNK_GZIP_SIZE);
}
async function build(compiler, isCi) {
  const stats = await new Promise((resolve, reject) => {
    compiler.run((err, buildStats) => {
      if (err) {
        if (err.message) {
          const {errors: errors2} = formatWebpackMessages2({
            errors: [err.message],
            warnings: new Array()
          });
          throw new Error(errors2[0]);
        } else {
          reject(err);
        }
      } else {
        resolve(buildStats);
      }
    });
  });
  const {errors, warnings} = formatWebpackMessages2(stats.toJson({all: false, warnings: true, errors: true}));
  if (errors.length) {
    throw new Error(errors[0]);
  }
  if (isCi && warnings.length) {
    console.log(chalk2.yellow("\nTreating warnings as errors because process.env.CI = true.\n"));
    throw new Error(warnings.join("\n\n"));
  }
  return {stats};
}

exports.buildBundle = buildBundle;
