'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs-extra'));
var webpack2 = _interopDefault(require('webpack'));
var paths = require('./paths-5bdff86a.js');
var WebpackDevServer = _interopDefault(require('webpack-dev-server'));
var openBrowser2 = _interopDefault(require('react-dev-utils/openBrowser'));

async function serveBundle(options) {
  var _a, _b;
  const url = paths.resolveBaseUrl(options.config);
  const port = Number(url.port) || (url.protocol === "https:" ? 443 : 80);
  const paths2 = paths.resolveBundlingPaths(options);
  const pkgPath = paths2.targetPackageJson;
  const pkg = await fs.readJson(pkgPath);
  const config2 = paths.createConfig(paths2, {
    ...options,
    isDev: true,
    baseUrl: url
  });
  const compiler = webpack2(config2);
  const server = new WebpackDevServer(compiler, {
    hot: true,
    contentBase: paths2.targetPublic,
    contentBasePublicPath: (_a = config2.output) == null ? void 0 : _a.publicPath,
    publicPath: (_b = config2.output) == null ? void 0 : _b.publicPath,
    historyApiFallback: true,
    clientLogLevel: "warning",
    stats: "errors-warnings",
    https: url.protocol === "https:",
    host: url.hostname,
    port,
    proxy: pkg.proxy
  });
  await new Promise((resolve, reject) => {
    server.listen(port, url.hostname, (err) => {
      if (err) {
        reject(err);
        return;
      }
      openBrowser2(url.href);
      resolve();
    });
  });
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        server.close();
        process.exit();
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}

exports.serveBundle = serveBundle;
