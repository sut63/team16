import fs from 'fs-extra';
import { resolve, dirname, basename, extname } from 'path';
import yaml2 from 'yaml';
import { object, string, lazy, array, ValidationError } from 'yup';

function findRootPath(topPath) {
  let path2 = topPath;
  for (let i = 0; i < 1e3; i++) {
    const packagePath = resolve(path2, "package.json");
    const exists = fs.pathExistsSync(packagePath);
    if (exists) {
      try {
        const data = fs.readJsonSync(packagePath);
        if (data.name === "root" || data.name.includes("backstage-e2e")) {
          return path2;
        }
      } catch (error) {
        throw new Error(`Failed to parse package.json file while searching for root, ${error}`);
      }
    }
    const newPath = dirname(path2);
    if (newPath === path2) {
      throw new Error(`No package.json with name "root" found as a parent of ${topPath}`);
    }
    path2 = newPath;
  }
  throw new Error(`Iteration limit reached when searching for root package.json at ${topPath}`);
}

async function resolveStaticConfig(options) {
  let {configPath} = options;
  if (!configPath) {
    configPath = resolve(findRootPath(fs.realpathSync(process.cwd())), "app-config.yaml");
  }
  return [configPath];
}

function isObject(obj) {
  if (typeof obj !== "object") {
    return false;
  } else if (Array.isArray(obj)) {
    return false;
  }
  return obj !== null;
}

async function readConfigFile(filePath, ctx) {
  const configYaml = await ctx.readFile(filePath);
  const config2 = yaml2.parse(configYaml);
  async function transform(obj, path2) {
    if (typeof obj !== "object") {
      return obj;
    } else if (obj === null) {
      return void 0;
    } else if (Array.isArray(obj)) {
      const arr = new Array();
      for (const [index, value] of obj.entries()) {
        const out2 = await transform(value, `${path2}[${index}]`);
        if (out2 !== void 0) {
          arr.push(out2);
        }
      }
      return arr;
    }
    if ("$secret" in obj) {
      if (!isObject(obj.$secret)) {
        throw TypeError(`Expected object at secret ${path2}.$secret`);
      }
      try {
        return await ctx.readSecret(obj.$secret);
      } catch (error) {
        throw new Error(`Invalid secret at ${path2}: ${error.message}`);
      }
    }
    const out = {};
    for (const [key, value] of Object.entries(obj)) {
      if (value !== void 0) {
        const result = await transform(value, `${path2}.${key}`);
        if (result !== void 0) {
          out[key] = result;
        }
      }
    }
    return out;
  }
  const finalConfig = await transform(config2, "");
  if (!isObject(finalConfig)) {
    throw new TypeError("Expected object at config root");
  }
  return {data: finalConfig, context: basename(filePath)};
}

const ENV_PREFIX = "APP_CONFIG_";
const CONFIG_KEY_PART_PATTERN = /^[a-z][a-z0-9]*(?:[-_][a-z][a-z0-9]*)*$/i;
function readEnv(env) {
  var _a;
  let data = void 0;
  for (const [name, value] of Object.entries(env)) {
    if (!value) {
      continue;
    }
    if (name.startsWith(ENV_PREFIX)) {
      const key = name.replace(ENV_PREFIX, "");
      const keyParts = key.split("_");
      let obj = data = data != null ? data : {};
      for (const [index, part] of keyParts.entries()) {
        if (!CONFIG_KEY_PART_PATTERN.test(part)) {
          throw new TypeError(`Invalid env config key '${key}'`);
        }
        if (index < keyParts.length - 1) {
          obj = obj[part] = (_a = obj[part]) != null ? _a : {};
          if (typeof obj !== "object" || Array.isArray(obj)) {
            const subKey = keyParts.slice(0, index + 1).join("_");
            throw new TypeError(`Could not nest config for key '${key}' under existing value '${subKey}'`);
          }
        } else {
          if (part in obj) {
            throw new TypeError(`Refusing to override existing config at key '${key}'`);
          }
          try {
            const parsedValue = JSON.parse(value);
            if (parsedValue === null) {
              throw new Error("value may not be null");
            }
            obj[part] = parsedValue;
          } catch (error) {
            throw new TypeError(`Failed to parse JSON-serialized config value for key '${key}', ${error}`);
          }
        }
      }
    }
  }
  return data ? [{data, context: "env"}] : [];
}

const secretLoaderSchemas = {
  file: object({
    file: string().required()
  }),
  env: object({
    env: string().required()
  }),
  data: object({
    data: string().required(),
    path: lazy((value) => {
      if (typeof value === "string") {
        return string().required();
      }
      return array().of(string().required()).required();
    })
  })
};
const secretSchema = lazy((value) => {
  if (typeof value !== "object" || value === null) {
    return object().required().label("secret");
  }
  const loaderTypes = Object.keys(secretLoaderSchemas);
  for (const key of loaderTypes) {
    if (key in value) {
      return secretLoaderSchemas[key];
    }
  }
  throw new ValidationError(`Secret must contain one of '${loaderTypes.join("', '")}'`, value, "$secret");
});
const dataSecretParser = {
  ".json": async (content) => JSON.parse(content),
  ".yaml": async (content) => yaml2.parse(content),
  ".yml": async (content) => yaml2.parse(content)
};
async function readSecret(data, ctx) {
  const secret = secretSchema.validateSync(data, {strict: true});
  if ("file" in secret) {
    return ctx.readFile(secret.file);
  }
  if ("env" in secret) {
    return ctx.env[secret.env];
  }
  if ("data" in secret) {
    const ext = extname(secret.data);
    const parser = dataSecretParser[ext];
    if (!parser) {
      throw new Error(`No data secret parser available for extension ${ext}`);
    }
    const content = await ctx.readFile(secret.data);
    const {path: path2} = secret;
    const parts = typeof path2 === "string" ? path2.split(".") : path2;
    let value = await parser(content);
    for (const [index, part] of parts.entries()) {
      if (!isObject(value)) {
        const errPath = parts.slice(0, index).join(".");
        throw new Error(`Value is not an object at ${errPath} in ${secret.data}`);
      }
      value = value[part];
    }
    return String(value);
  }
  throw new Error("Secret was left unhandled");
}

class Context {
  constructor(options) {
    this.options = options;
  }
  get env() {
    return this.options.env;
  }
  async readFile(path2) {
    return fs.readFile(resolve(this.options.rootPath, path2), "utf8");
  }
  async readSecret(desc) {
    if (!this.options.shouldReadSecrets) {
      return void 0;
    }
    return readSecret(desc, this);
  }
}
async function loadConfig(options = {}) {
  const configs = [];
  configs.push(...readEnv(process.env));
  const configPaths = await resolveStaticConfig(options);
  try {
    for (const configPath of configPaths) {
      const config2 = await readConfigFile(configPath, new Context({
        env: process.env,
        rootPath: dirname(configPath),
        shouldReadSecrets: Boolean(options.shouldReadSecrets)
      }));
      configs.push(config2);
    }
  } catch (error) {
    throw new Error(`Failed to read static configuration file: ${error.message}`);
  }
  return configs;
}

export { loadConfig };
