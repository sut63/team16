import cloneDeep2 from 'lodash/cloneDeep';
import mergeWith2 from 'lodash/mergeWith';

const CONFIG_KEY_PART_PATTERN = /^[a-z][a-z0-9]*(?:[-_][a-z][a-z0-9]*)*$/i;
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function typeOf(value) {
  if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  }
  const type = typeof value;
  if (type === "number" && isNaN(value)) {
    return "nan";
  }
  if (type === "string" && value === "") {
    return "empty-string";
  }
  return type;
}
const errors = {
  type(key, context, typeName, expected) {
    return `Invalid type in config for key '${key}' in '${context}', got ${typeName}, wanted ${expected}`;
  },
  missing(key) {
    return `Missing required config value at '${key}'`;
  }
};
class ConfigReader {
  constructor(data, context = "empty-config", fallback, prefix = "") {
    this.data = data;
    this.context = context;
    this.fallback = fallback;
    this.prefix = prefix;
  }
  static fromConfigs(configs) {
    if (configs.length === 0) {
      return new ConfigReader(void 0);
    }
    return configs.reduceRight((previousReader, {data, context}) => {
      return new ConfigReader(data, context, previousReader);
    }, void 0);
  }
  keys() {
    var _a, _b;
    const localKeys = this.data ? Object.keys(this.data) : [];
    const fallbackKeys = (_b = (_a = this.fallback) == null ? void 0 : _a.keys()) != null ? _b : [];
    return [...new Set([...localKeys, ...fallbackKeys])];
  }
  get(key) {
    const value = this.getOptional(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptional(key) {
    var _a;
    const value = this.readValue(key);
    const fallbackValue = (_a = this.fallback) == null ? void 0 : _a.getOptional(key);
    if (value === void 0) {
      return fallbackValue;
    } else if (fallbackValue === void 0) {
      return value;
    }
    return mergeWith2({}, {value: cloneDeep2(fallbackValue)}, {value}, (into, from) => !isObject(from) || !isObject(into) ? from : void 0).value;
  }
  getConfig(key) {
    const value = this.getOptionalConfig(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalConfig(key) {
    var _a;
    const value = this.readValue(key);
    const fallbackConfig = (_a = this.fallback) == null ? void 0 : _a.getOptionalConfig(key);
    const prefix = this.fullKey(key);
    if (isObject(value)) {
      return new ConfigReader(value, this.context, fallbackConfig, prefix);
    }
    if (value !== void 0) {
      throw new TypeError(errors.type(this.fullKey(key), this.context, typeOf(value), "object"));
    }
    return fallbackConfig;
  }
  getConfigArray(key) {
    const value = this.getOptionalConfigArray(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalConfigArray(key) {
    const configs = this.readConfigValue(key, (values) => {
      if (!Array.isArray(values)) {
        return {expected: "object-array"};
      }
      for (const [index, value] of values.entries()) {
        if (!isObject(value)) {
          return {expected: "object-array", value, key: `${key}[${index}]`};
        }
      }
      return true;
    });
    if (!configs) {
      return void 0;
    }
    return configs.map((obj, index) => new ConfigReader(obj, this.context, void 0, this.fullKey(`${key}[${index}]`)));
  }
  getNumber(key) {
    const value = this.getOptionalNumber(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalNumber(key) {
    return this.readConfigValue(key, (value) => typeof value === "number" || {expected: "number"});
  }
  getBoolean(key) {
    const value = this.getOptionalBoolean(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalBoolean(key) {
    return this.readConfigValue(key, (value) => typeof value === "boolean" || {expected: "boolean"});
  }
  getString(key) {
    const value = this.getOptionalString(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalString(key) {
    return this.readConfigValue(key, (value) => typeof value === "string" && value !== "" || {expected: "string"});
  }
  getStringArray(key) {
    const value = this.getOptionalStringArray(key);
    if (value === void 0) {
      throw new Error(errors.missing(this.fullKey(key)));
    }
    return value;
  }
  getOptionalStringArray(key) {
    return this.readConfigValue(key, (values) => {
      if (!Array.isArray(values)) {
        return {expected: "string-array"};
      }
      for (const [index, value] of values.entries()) {
        if (typeof value !== "string" || value === "") {
          return {expected: "string-array", value, key: `${key}[${index}]`};
        }
      }
      return true;
    });
  }
  fullKey(key) {
    return `${this.prefix}${this.prefix ? "." : ""}${key}`;
  }
  readConfigValue(key, validate) {
    var _a;
    const value = this.readValue(key);
    if (value === void 0) {
      return (_a = this.fallback) == null ? void 0 : _a.readConfigValue(key, validate);
    }
    if (value !== void 0) {
      const result = validate(value);
      if (result !== true) {
        const {
          key: keyName = key,
          value: theValue = value,
          expected
        } = result;
        throw new TypeError(errors.type(this.fullKey(keyName), this.context, typeOf(theValue), expected));
      }
    }
    return value;
  }
  readValue(key) {
    const parts = key.split(".");
    for (const part of parts) {
      if (!CONFIG_KEY_PART_PATTERN.test(part)) {
        throw new TypeError(`Invalid config key '${key}'`);
      }
    }
    if (this.data === void 0) {
      return void 0;
    }
    let value = this.data;
    for (const [index, part] of parts.entries()) {
      if (isObject(value)) {
        value = value[part];
      } else if (value !== void 0) {
        const badKey = this.fullKey(parts.slice(0, index).join("."));
        throw new TypeError(errors.type(badKey, this.context, typeOf(value), "object"));
      }
    }
    return value;
  }
}

export { ConfigReader };
