'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs2 = require('fs');
var fs2__default = _interopDefault(fs2);
var path = require('path');
var esbuild = require('esbuild');
var pluginutils = require('@rollup/pluginutils');
var JoyCon = _interopDefault(require('joycon'));
var strip = _interopDefault(require('strip-json-comments'));

const joycon2 = new JoyCon();
joycon2.addLoader({
  test: /\.json$/,
  load: async (file) => {
    const content = await fs2__default.promises.readFile(file, "utf8");
    return JSON.parse(strip(content));
  }
});
const getOptions = async (cwd, tsconfig) => {
  var _a, _b, _c;
  const {data, path} = await joycon2.load([tsconfig || "tsconfig.json"], cwd);
  if (path && data) {
    return {
      jsxFactory: (_a = data.compilerOptions) == null ? void 0 : _a.jsxFactory,
      jsxFragment: (_b = data.compilerOptions) == null ? void 0 : _b.jsxFragmentFactory,
      target: (_c = data.compilerOptions) == null ? void 0 : _c.target
    };
  }
  return {};
};

const defaultLoaders = {
  ".js": "js",
  ".jsx": "jsx",
  ".ts": "ts",
  ".tsx": "tsx"
};
var index = (options2 = {}) => {
  const loaders = {
    ...defaultLoaders
  };
  if (options2.loaders) {
    for (const key of Object.keys(options2.loaders)) {
      const value = options2.loaders[key];
      if (typeof value === "string") {
        loaders[key] = value;
      } else if (value === false) {
        delete loaders[key];
      }
    }
  }
  const extensions = Object.keys(loaders);
  const INCLUDE_REGEXP = new RegExp(`\\.(${extensions.map((ext) => ext.slice(1)).join("|")})$`);
  const EXCLUDE_REGEXP = /node_modules/;
  const filter = pluginutils.createFilter(options2.include || INCLUDE_REGEXP, options2.exclude || EXCLUDE_REGEXP);
  let service;
  const stopService = () => {
    if (!options2.watch && service) {
      service.stop();
      service = void 0;
    }
  };
  const resolveFile = (resolved, index = false) => {
    for (const ext of extensions) {
      const file = index ? path.join(resolved, `index${ext}`) : `${resolved}${ext}`;
      if (fs2.existsSync(file))
        return file;
    }
    return null;
  };
  return {
    name: "esbuild",
    async buildStart() {
      if (!service) {
        service = await esbuild.startService();
      }
    },
    resolveId(importee, importer) {
      if (importer && importee[0] === ".") {
        const resolved = path.resolve(importer ? path.dirname(importer) : process.cwd(), importee);
        let file = resolveFile(resolved);
        if (file)
          return file;
        if (!file && fs2.existsSync(resolved) && fs2.statSync(resolved).isDirectory()) {
          file = resolveFile(resolved, true);
          if (file)
            return file;
        }
      }
    },
    async transform(code, id) {
      if (!filter(id)) {
        return null;
      }
      const ext = path.extname(id);
      const loader = loaders[ext];
      if (!loader || !service) {
        return null;
      }
      const defaultOptions = options2.tsconfig === false ? {} : await getOptions(path.dirname(id), options2.tsconfig);
      const result = await service.transform(code, {
        loader,
        target: options2.target || defaultOptions.target || "es2017",
        jsxFactory: options2.jsxFactory || defaultOptions.jsxFactory,
        jsxFragment: options2.jsxFragment || defaultOptions.jsxFragment,
        define: options2.define,
        sourcemap: options2.sourceMap
      });
      printWarnings(id, result, this);
      return result.js && {
        code: result.js,
        map: result.jsSourceMap || null
      };
    },
    buildEnd(error) {
      if (error) {
        stopService();
      }
    },
    async renderChunk(code) {
      if (options2.minify && service) {
        const result = await service.transform(code, {
          loader: "js",
          target: "esnext",
          minify: true
        });
        if (result.js) {
          return {
            code: result.js,
            map: result.jsSourceMap || null
          };
        }
      }
      return null;
    },
    generateBundle() {
      stopService();
    }
  };
};
function printWarnings(id, result, plugin) {
  if (result.warnings) {
    for (const warning of result.warnings) {
      let message = `[esbuild]`;
      if (warning.location) {
        message += ` (${path.relative(process.cwd(), id)}:${warning.location.line}:${warning.location.column})`;
      }
      message += ` ${warning.text}`;
      plugin.warn(message);
    }
  }
}

module.exports = index;
