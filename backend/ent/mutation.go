// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/G16/app/ent/age"
	"github.com/G16/app/ent/bookcourse"
	"github.com/G16/app/ent/classifier"
	"github.com/G16/app/ent/course"
	"github.com/G16/app/ent/employee"
	"github.com/G16/app/ent/equipment"
	"github.com/G16/app/ent/equipmentrental"
	"github.com/G16/app/ent/equipmenttype"
	"github.com/G16/app/ent/member"
	"github.com/G16/app/ent/payment"
	"github.com/G16/app/ent/paymenttype"
	"github.com/G16/app/ent/position"
	"github.com/G16/app/ent/promotion"
	"github.com/G16/app/ent/promotionamount"
	"github.com/G16/app/ent/promotiontype"
	"github.com/G16/app/ent/salary"
	"github.com/G16/app/ent/zone"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAge             = "Age"
	TypeBookcourse      = "Bookcourse"
	TypeClassifier      = "Classifier"
	TypeCourse          = "Course"
	TypeEmployee        = "Employee"
	TypeEquipment       = "Equipment"
	TypeEquipmentrental = "Equipmentrental"
	TypeEquipmenttype   = "Equipmenttype"
	TypeMember          = "Member"
	TypePayment         = "Payment"
	TypePaymenttype     = "Paymenttype"
	TypePosition        = "Position"
	TypePromotion       = "Promotion"
	TypePromotionamount = "Promotionamount"
	TypePromotiontype   = "Promotiontype"
	TypeSalary          = "Salary"
	TypeZone            = "Zone"
)

// AgeMutation represents an operation that mutate the Ages
// nodes in the graph.
type AgeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_AGE            *int
	add_AGE         *int
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Age, error)
}

var _ ent.Mutation = (*AgeMutation)(nil)

// ageOption allows to manage the mutation configuration using functional options.
type ageOption func(*AgeMutation)

// newAgeMutation creates new mutation for $n.Name.
func newAgeMutation(c config, op Op, opts ...ageOption) *AgeMutation {
	m := &AgeMutation{
		config:        c,
		op:            op,
		typ:           TypeAge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgeID sets the id field of the mutation.
func withAgeID(id int) ageOption {
	return func(m *AgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Age
		)
		m.oldValue = func(ctx context.Context) (*Age, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Age.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAge sets the old Age of the mutation.
func withAge(node *Age) ageOption {
	return func(m *AgeMutation) {
		m.oldValue = func(context.Context) (*Age, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAGE sets the AGE field.
func (m *AgeMutation) SetAGE(i int) {
	m._AGE = &i
	m.add_AGE = nil
}

// AGE returns the AGE value in the mutation.
func (m *AgeMutation) AGE() (r int, exists bool) {
	v := m._AGE
	if v == nil {
		return
	}
	return *v, true
}

// OldAGE returns the old AGE value of the Age.
// If the Age object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AgeMutation) OldAGE(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAGE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAGE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAGE: %w", err)
	}
	return oldValue.AGE, nil
}

// AddAGE adds i to AGE.
func (m *AgeMutation) AddAGE(i int) {
	if m.add_AGE != nil {
		*m.add_AGE += i
	} else {
		m.add_AGE = &i
	}
}

// AddedAGE returns the value that was added to the AGE field in this mutation.
func (m *AgeMutation) AddedAGE() (r int, exists bool) {
	v := m.add_AGE
	if v == nil {
		return
	}
	return *v, true
}

// ResetAGE reset all changes of the "AGE" field.
func (m *AgeMutation) ResetAGE() {
	m._AGE = nil
	m.add_AGE = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *AgeMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *AgeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *AgeMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *AgeMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *AgeMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *AgeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Age).
func (m *AgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AgeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AGE != nil {
		fields = append(fields, age.FieldAGE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case age.FieldAGE:
		return m.AGE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case age.FieldAGE:
		return m.OldAGE(ctx)
	}
	return nil, fmt.Errorf("unknown Age field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case age.FieldAGE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAGE(v)
		return nil
	}
	return fmt.Errorf("unknown Age field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AgeMutation) AddedFields() []string {
	var fields []string
	if m.add_AGE != nil {
		fields = append(fields, age.FieldAGE)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AgeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case age.FieldAGE:
		return m.AddedAGE()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case age.FieldAGE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAGE(v)
		return nil
	}
	return fmt.Errorf("unknown Age numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Age nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AgeMutation) ResetField(name string) error {
	switch name {
	case age.FieldAGE:
		m.ResetAGE()
		return nil
	}
	return fmt.Errorf("unknown Age field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, age.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case age.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, age.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case age.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AgeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Age unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AgeMutation) ResetEdge(name string) error {
	switch name {
	case age.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Age edge %s", name)
}

// BookcourseMutation represents an operation that mutate the Bookcourses
// nodes in the graph.
type BookcourseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_BOOKTIME       *time.Time
	clearedFields   map[string]struct{}
	course          *int
	clearedcourse   bool
	employee        *int
	clearedemployee bool
	member          *int
	clearedmember   bool
	done            bool
	oldValue        func(context.Context) (*Bookcourse, error)
}

var _ ent.Mutation = (*BookcourseMutation)(nil)

// bookcourseOption allows to manage the mutation configuration using functional options.
type bookcourseOption func(*BookcourseMutation)

// newBookcourseMutation creates new mutation for $n.Name.
func newBookcourseMutation(c config, op Op, opts ...bookcourseOption) *BookcourseMutation {
	m := &BookcourseMutation{
		config:        c,
		op:            op,
		typ:           TypeBookcourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookcourseID sets the id field of the mutation.
func withBookcourseID(id int) bookcourseOption {
	return func(m *BookcourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Bookcourse
		)
		m.oldValue = func(ctx context.Context) (*Bookcourse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bookcourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookcourse sets the old Bookcourse of the mutation.
func withBookcourse(node *Bookcourse) bookcourseOption {
	return func(m *BookcourseMutation) {
		m.oldValue = func(context.Context) (*Bookcourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookcourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookcourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookcourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBOOKTIME sets the BOOKTIME field.
func (m *BookcourseMutation) SetBOOKTIME(t time.Time) {
	m._BOOKTIME = &t
}

// BOOKTIME returns the BOOKTIME value in the mutation.
func (m *BookcourseMutation) BOOKTIME() (r time.Time, exists bool) {
	v := m._BOOKTIME
	if v == nil {
		return
	}
	return *v, true
}

// OldBOOKTIME returns the old BOOKTIME value of the Bookcourse.
// If the Bookcourse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookcourseMutation) OldBOOKTIME(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBOOKTIME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBOOKTIME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBOOKTIME: %w", err)
	}
	return oldValue.BOOKTIME, nil
}

// ResetBOOKTIME reset all changes of the "BOOKTIME" field.
func (m *BookcourseMutation) ResetBOOKTIME() {
	m._BOOKTIME = nil
}

// SetCourseID sets the course edge to Course by id.
func (m *BookcourseMutation) SetCourseID(id int) {
	m.course = &id
}

// ClearCourse clears the course edge to Course.
func (m *BookcourseMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared returns if the edge course was cleared.
func (m *BookcourseMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the course id in the mutation.
func (m *BookcourseMutation) CourseID() (id int, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the course ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *BookcourseMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse reset all changes of the "course" edge.
func (m *BookcourseMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *BookcourseMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *BookcourseMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *BookcourseMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *BookcourseMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BookcourseMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *BookcourseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetMemberID sets the member edge to Member by id.
func (m *BookcourseMutation) SetMemberID(id int) {
	m.member = &id
}

// ClearMember clears the member edge to Member.
func (m *BookcourseMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared returns if the edge member was cleared.
func (m *BookcourseMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the member id in the mutation.
func (m *BookcourseMutation) MemberID() (id int, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the member ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *BookcourseMutation) MemberIDs() (ids []int) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember reset all changes of the "member" edge.
func (m *BookcourseMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Op returns the operation name.
func (m *BookcourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bookcourse).
func (m *BookcourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookcourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._BOOKTIME != nil {
		fields = append(fields, bookcourse.FieldBOOKTIME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookcourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookcourse.FieldBOOKTIME:
		return m.BOOKTIME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookcourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookcourse.FieldBOOKTIME:
		return m.OldBOOKTIME(ctx)
	}
	return nil, fmt.Errorf("unknown Bookcourse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookcourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookcourse.FieldBOOKTIME:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBOOKTIME(v)
		return nil
	}
	return fmt.Errorf("unknown Bookcourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookcourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookcourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookcourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bookcourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookcourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookcourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookcourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bookcourse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookcourseMutation) ResetField(name string) error {
	switch name {
	case bookcourse.FieldBOOKTIME:
		m.ResetBOOKTIME()
		return nil
	}
	return fmt.Errorf("unknown Bookcourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookcourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, bookcourse.EdgeCourse)
	}
	if m.employee != nil {
		edges = append(edges, bookcourse.EdgeEmployee)
	}
	if m.member != nil {
		edges = append(edges, bookcourse.EdgeMember)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookcourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookcourse.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case bookcourse.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case bookcourse.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookcourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookcourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookcourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, bookcourse.EdgeCourse)
	}
	if m.clearedemployee {
		edges = append(edges, bookcourse.EdgeEmployee)
	}
	if m.clearedmember {
		edges = append(edges, bookcourse.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookcourseMutation) EdgeCleared(name string) bool {
	switch name {
	case bookcourse.EdgeCourse:
		return m.clearedcourse
	case bookcourse.EdgeEmployee:
		return m.clearedemployee
	case bookcourse.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookcourseMutation) ClearEdge(name string) error {
	switch name {
	case bookcourse.EdgeCourse:
		m.ClearCourse()
		return nil
	case bookcourse.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case bookcourse.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown Bookcourse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookcourseMutation) ResetEdge(name string) error {
	switch name {
	case bookcourse.EdgeCourse:
		m.ResetCourse()
		return nil
	case bookcourse.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case bookcourse.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown Bookcourse edge %s", name)
}

// ClassifierMutation represents an operation that mutate the Classifiers
// nodes in the graph.
type ClassifierMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_EQUIPMENTCLASSIFIER *string
	clearedFields        map[string]struct{}
	equipment            map[int]struct{}
	removedequipment     map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Classifier, error)
}

var _ ent.Mutation = (*ClassifierMutation)(nil)

// classifierOption allows to manage the mutation configuration using functional options.
type classifierOption func(*ClassifierMutation)

// newClassifierMutation creates new mutation for $n.Name.
func newClassifierMutation(c config, op Op, opts ...classifierOption) *ClassifierMutation {
	m := &ClassifierMutation{
		config:        c,
		op:            op,
		typ:           TypeClassifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassifierID sets the id field of the mutation.
func withClassifierID(id int) classifierOption {
	return func(m *ClassifierMutation) {
		var (
			err   error
			once  sync.Once
			value *Classifier
		)
		m.oldValue = func(ctx context.Context) (*Classifier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassifier sets the old Classifier of the mutation.
func withClassifier(node *Classifier) classifierOption {
	return func(m *ClassifierMutation) {
		m.oldValue = func(context.Context) (*Classifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClassifierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEQUIPMENTCLASSIFIER sets the EQUIPMENTCLASSIFIER field.
func (m *ClassifierMutation) SetEQUIPMENTCLASSIFIER(s string) {
	m._EQUIPMENTCLASSIFIER = &s
}

// EQUIPMENTCLASSIFIER returns the EQUIPMENTCLASSIFIER value in the mutation.
func (m *ClassifierMutation) EQUIPMENTCLASSIFIER() (r string, exists bool) {
	v := m._EQUIPMENTCLASSIFIER
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTCLASSIFIER returns the old EQUIPMENTCLASSIFIER value of the Classifier.
// If the Classifier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClassifierMutation) OldEQUIPMENTCLASSIFIER(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTCLASSIFIER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTCLASSIFIER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTCLASSIFIER: %w", err)
	}
	return oldValue.EQUIPMENTCLASSIFIER, nil
}

// ResetEQUIPMENTCLASSIFIER reset all changes of the "EQUIPMENTCLASSIFIER" field.
func (m *ClassifierMutation) ResetEQUIPMENTCLASSIFIER() {
	m._EQUIPMENTCLASSIFIER = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *ClassifierMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *ClassifierMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *ClassifierMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *ClassifierMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *ClassifierMutation) ResetEquipment() {
	m.equipment = nil
	m.removedequipment = nil
}

// Op returns the operation name.
func (m *ClassifierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Classifier).
func (m *ClassifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClassifierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._EQUIPMENTCLASSIFIER != nil {
		fields = append(fields, classifier.FieldEQUIPMENTCLASSIFIER)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClassifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classifier.FieldEQUIPMENTCLASSIFIER:
		return m.EQUIPMENTCLASSIFIER()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClassifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classifier.FieldEQUIPMENTCLASSIFIER:
		return m.OldEQUIPMENTCLASSIFIER(ctx)
	}
	return nil, fmt.Errorf("unknown Classifier field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classifier.FieldEQUIPMENTCLASSIFIER:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTCLASSIFIER(v)
		return nil
	}
	return fmt.Errorf("unknown Classifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClassifierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClassifierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClassifierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClassifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassifierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Classifier nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClassifierMutation) ResetField(name string) error {
	switch name {
	case classifier.FieldEQUIPMENTCLASSIFIER:
		m.ResetEQUIPMENTCLASSIFIER()
		return nil
	}
	return fmt.Errorf("unknown Classifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClassifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, classifier.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClassifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classifier.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClassifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedequipment != nil {
		edges = append(edges, classifier.EdgeEquipment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClassifierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classifier.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClassifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClassifierMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClassifierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Classifier unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClassifierMutation) ResetEdge(name string) error {
	switch name {
	case classifier.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Classifier edge %s", name)
}

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_COURSE           *string
	clearedFields     map[string]struct{}
	bookcourse        map[int]struct{}
	removedbookcourse map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCOURSE sets the COURSE field.
func (m *CourseMutation) SetCOURSE(s string) {
	m._COURSE = &s
}

// COURSE returns the COURSE value in the mutation.
func (m *CourseMutation) COURSE() (r string, exists bool) {
	v := m._COURSE
	if v == nil {
		return
	}
	return *v, true
}

// OldCOURSE returns the old COURSE value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCOURSE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCOURSE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCOURSE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCOURSE: %w", err)
	}
	return oldValue.COURSE, nil
}

// ResetCOURSE reset all changes of the "COURSE" field.
func (m *CourseMutation) ResetCOURSE() {
	m._COURSE = nil
}

// AddBookcourseIDs adds the bookcourse edge to Bookcourse by ids.
func (m *CourseMutation) AddBookcourseIDs(ids ...int) {
	if m.bookcourse == nil {
		m.bookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.bookcourse[ids[i]] = struct{}{}
	}
}

// RemoveBookcourseIDs removes the bookcourse edge to Bookcourse by ids.
func (m *CourseMutation) RemoveBookcourseIDs(ids ...int) {
	if m.removedbookcourse == nil {
		m.removedbookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbookcourse[ids[i]] = struct{}{}
	}
}

// RemovedBookcourse returns the removed ids of bookcourse.
func (m *CourseMutation) RemovedBookcourseIDs() (ids []int) {
	for id := range m.removedbookcourse {
		ids = append(ids, id)
	}
	return
}

// BookcourseIDs returns the bookcourse ids in the mutation.
func (m *CourseMutation) BookcourseIDs() (ids []int) {
	for id := range m.bookcourse {
		ids = append(ids, id)
	}
	return
}

// ResetBookcourse reset all changes of the "bookcourse" edge.
func (m *CourseMutation) ResetBookcourse() {
	m.bookcourse = nil
	m.removedbookcourse = nil
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._COURSE != nil {
		fields = append(fields, course.FieldCOURSE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCOURSE:
		return m.COURSE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCOURSE:
		return m.OldCOURSE(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCOURSE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCOURSE(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCOURSE:
		m.ResetCOURSE()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bookcourse != nil {
		edges = append(edges, course.EdgeBookcourse)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.bookcourse))
		for id := range m.bookcourse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbookcourse != nil {
		edges = append(edges, course.EdgeBookcourse)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.removedbookcourse))
		for id := range m.removedbookcourse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeBookcourse:
		m.ResetBookcourse()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_EMPLOYEEID            *string
	_EMPLOYEENAME          *string
	_EMPLOYEEADDRESS       *string
	_IDCARDNUMBER          *string
	clearedFields          map[string]struct{}
	age                    *int
	clearedage             bool
	position               *int
	clearedposition        bool
	salary                 *int
	clearedsalary          bool
	payment                map[int]struct{}
	removedpayment         map[int]struct{}
	equipment              map[int]struct{}
	removedequipment       map[int]struct{}
	bookcourse             map[int]struct{}
	removedbookcourse      map[int]struct{}
	equipmentrental        map[int]struct{}
	removedequipmentrental map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEMPLOYEEID sets the EMPLOYEEID field.
func (m *EmployeeMutation) SetEMPLOYEEID(s string) {
	m._EMPLOYEEID = &s
}

// EMPLOYEEID returns the EMPLOYEEID value in the mutation.
func (m *EmployeeMutation) EMPLOYEEID() (r string, exists bool) {
	v := m._EMPLOYEEID
	if v == nil {
		return
	}
	return *v, true
}

// OldEMPLOYEEID returns the old EMPLOYEEID value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEMPLOYEEID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMPLOYEEID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMPLOYEEID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMPLOYEEID: %w", err)
	}
	return oldValue.EMPLOYEEID, nil
}

// ResetEMPLOYEEID reset all changes of the "EMPLOYEEID" field.
func (m *EmployeeMutation) ResetEMPLOYEEID() {
	m._EMPLOYEEID = nil
}

// SetEMPLOYEENAME sets the EMPLOYEENAME field.
func (m *EmployeeMutation) SetEMPLOYEENAME(s string) {
	m._EMPLOYEENAME = &s
}

// EMPLOYEENAME returns the EMPLOYEENAME value in the mutation.
func (m *EmployeeMutation) EMPLOYEENAME() (r string, exists bool) {
	v := m._EMPLOYEENAME
	if v == nil {
		return
	}
	return *v, true
}

// OldEMPLOYEENAME returns the old EMPLOYEENAME value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEMPLOYEENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMPLOYEENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMPLOYEENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMPLOYEENAME: %w", err)
	}
	return oldValue.EMPLOYEENAME, nil
}

// ResetEMPLOYEENAME reset all changes of the "EMPLOYEENAME" field.
func (m *EmployeeMutation) ResetEMPLOYEENAME() {
	m._EMPLOYEENAME = nil
}

// SetEMPLOYEEADDRESS sets the EMPLOYEEADDRESS field.
func (m *EmployeeMutation) SetEMPLOYEEADDRESS(s string) {
	m._EMPLOYEEADDRESS = &s
}

// EMPLOYEEADDRESS returns the EMPLOYEEADDRESS value in the mutation.
func (m *EmployeeMutation) EMPLOYEEADDRESS() (r string, exists bool) {
	v := m._EMPLOYEEADDRESS
	if v == nil {
		return
	}
	return *v, true
}

// OldEMPLOYEEADDRESS returns the old EMPLOYEEADDRESS value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEMPLOYEEADDRESS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMPLOYEEADDRESS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMPLOYEEADDRESS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMPLOYEEADDRESS: %w", err)
	}
	return oldValue.EMPLOYEEADDRESS, nil
}

// ResetEMPLOYEEADDRESS reset all changes of the "EMPLOYEEADDRESS" field.
func (m *EmployeeMutation) ResetEMPLOYEEADDRESS() {
	m._EMPLOYEEADDRESS = nil
}

// SetIDCARDNUMBER sets the IDCARDNUMBER field.
func (m *EmployeeMutation) SetIDCARDNUMBER(s string) {
	m._IDCARDNUMBER = &s
}

// IDCARDNUMBER returns the IDCARDNUMBER value in the mutation.
func (m *EmployeeMutation) IDCARDNUMBER() (r string, exists bool) {
	v := m._IDCARDNUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCARDNUMBER returns the old IDCARDNUMBER value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldIDCARDNUMBER(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIDCARDNUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIDCARDNUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCARDNUMBER: %w", err)
	}
	return oldValue.IDCARDNUMBER, nil
}

// ResetIDCARDNUMBER reset all changes of the "IDCARDNUMBER" field.
func (m *EmployeeMutation) ResetIDCARDNUMBER() {
	m._IDCARDNUMBER = nil
}

// SetAgeID sets the age edge to Age by id.
func (m *EmployeeMutation) SetAgeID(id int) {
	m.age = &id
}

// ClearAge clears the age edge to Age.
func (m *EmployeeMutation) ClearAge() {
	m.clearedage = true
}

// AgeCleared returns if the edge age was cleared.
func (m *EmployeeMutation) AgeCleared() bool {
	return m.clearedage
}

// AgeID returns the age id in the mutation.
func (m *EmployeeMutation) AgeID() (id int, exists bool) {
	if m.age != nil {
		return *m.age, true
	}
	return
}

// AgeIDs returns the age ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AgeID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AgeIDs() (ids []int) {
	if id := m.age; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAge reset all changes of the "age" edge.
func (m *EmployeeMutation) ResetAge() {
	m.age = nil
	m.clearedage = false
}

// SetPositionID sets the position edge to Position by id.
func (m *EmployeeMutation) SetPositionID(id int) {
	m.position = &id
}

// ClearPosition clears the position edge to Position.
func (m *EmployeeMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared returns if the edge position was cleared.
func (m *EmployeeMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the position id in the mutation.
func (m *EmployeeMutation) PositionID() (id int, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the position ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) PositionIDs() (ids []int) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition reset all changes of the "position" edge.
func (m *EmployeeMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// SetSalaryID sets the salary edge to Salary by id.
func (m *EmployeeMutation) SetSalaryID(id int) {
	m.salary = &id
}

// ClearSalary clears the salary edge to Salary.
func (m *EmployeeMutation) ClearSalary() {
	m.clearedsalary = true
}

// SalaryCleared returns if the edge salary was cleared.
func (m *EmployeeMutation) SalaryCleared() bool {
	return m.clearedsalary
}

// SalaryID returns the salary id in the mutation.
func (m *EmployeeMutation) SalaryID() (id int, exists bool) {
	if m.salary != nil {
		return *m.salary, true
	}
	return
}

// SalaryIDs returns the salary ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SalaryID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) SalaryIDs() (ids []int) {
	if id := m.salary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSalary reset all changes of the "salary" edge.
func (m *EmployeeMutation) ResetSalary() {
	m.salary = nil
	m.clearedsalary = false
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *EmployeeMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *EmployeeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *EmployeeMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *EmployeeMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *EmployeeMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *EmployeeMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *EmployeeMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *EmployeeMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *EmployeeMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *EmployeeMutation) ResetEquipment() {
	m.equipment = nil
	m.removedequipment = nil
}

// AddBookcourseIDs adds the bookcourse edge to Bookcourse by ids.
func (m *EmployeeMutation) AddBookcourseIDs(ids ...int) {
	if m.bookcourse == nil {
		m.bookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.bookcourse[ids[i]] = struct{}{}
	}
}

// RemoveBookcourseIDs removes the bookcourse edge to Bookcourse by ids.
func (m *EmployeeMutation) RemoveBookcourseIDs(ids ...int) {
	if m.removedbookcourse == nil {
		m.removedbookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbookcourse[ids[i]] = struct{}{}
	}
}

// RemovedBookcourse returns the removed ids of bookcourse.
func (m *EmployeeMutation) RemovedBookcourseIDs() (ids []int) {
	for id := range m.removedbookcourse {
		ids = append(ids, id)
	}
	return
}

// BookcourseIDs returns the bookcourse ids in the mutation.
func (m *EmployeeMutation) BookcourseIDs() (ids []int) {
	for id := range m.bookcourse {
		ids = append(ids, id)
	}
	return
}

// ResetBookcourse reset all changes of the "bookcourse" edge.
func (m *EmployeeMutation) ResetBookcourse() {
	m.bookcourse = nil
	m.removedbookcourse = nil
}

// AddEquipmentrentalIDs adds the equipmentrental edge to Equipmentrental by ids.
func (m *EmployeeMutation) AddEquipmentrentalIDs(ids ...int) {
	if m.equipmentrental == nil {
		m.equipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.equipmentrental[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentrentalIDs removes the equipmentrental edge to Equipmentrental by ids.
func (m *EmployeeMutation) RemoveEquipmentrentalIDs(ids ...int) {
	if m.removedequipmentrental == nil {
		m.removedequipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipmentrental[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentrental returns the removed ids of equipmentrental.
func (m *EmployeeMutation) RemovedEquipmentrentalIDs() (ids []int) {
	for id := range m.removedequipmentrental {
		ids = append(ids, id)
	}
	return
}

// EquipmentrentalIDs returns the equipmentrental ids in the mutation.
func (m *EmployeeMutation) EquipmentrentalIDs() (ids []int) {
	for id := range m.equipmentrental {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentrental reset all changes of the "equipmentrental" edge.
func (m *EmployeeMutation) ResetEquipmentrental() {
	m.equipmentrental = nil
	m.removedequipmentrental = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._EMPLOYEEID != nil {
		fields = append(fields, employee.FieldEMPLOYEEID)
	}
	if m._EMPLOYEENAME != nil {
		fields = append(fields, employee.FieldEMPLOYEENAME)
	}
	if m._EMPLOYEEADDRESS != nil {
		fields = append(fields, employee.FieldEMPLOYEEADDRESS)
	}
	if m._IDCARDNUMBER != nil {
		fields = append(fields, employee.FieldIDCARDNUMBER)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEMPLOYEEID:
		return m.EMPLOYEEID()
	case employee.FieldEMPLOYEENAME:
		return m.EMPLOYEENAME()
	case employee.FieldEMPLOYEEADDRESS:
		return m.EMPLOYEEADDRESS()
	case employee.FieldIDCARDNUMBER:
		return m.IDCARDNUMBER()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEMPLOYEEID:
		return m.OldEMPLOYEEID(ctx)
	case employee.FieldEMPLOYEENAME:
		return m.OldEMPLOYEENAME(ctx)
	case employee.FieldEMPLOYEEADDRESS:
		return m.OldEMPLOYEEADDRESS(ctx)
	case employee.FieldIDCARDNUMBER:
		return m.OldIDCARDNUMBER(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEMPLOYEEID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMPLOYEEID(v)
		return nil
	case employee.FieldEMPLOYEENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMPLOYEENAME(v)
		return nil
	case employee.FieldEMPLOYEEADDRESS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMPLOYEEADDRESS(v)
		return nil
	case employee.FieldIDCARDNUMBER:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCARDNUMBER(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEMPLOYEEID:
		m.ResetEMPLOYEEID()
		return nil
	case employee.FieldEMPLOYEENAME:
		m.ResetEMPLOYEENAME()
		return nil
	case employee.FieldEMPLOYEEADDRESS:
		m.ResetEMPLOYEEADDRESS()
		return nil
	case employee.FieldIDCARDNUMBER:
		m.ResetIDCARDNUMBER()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.age != nil {
		edges = append(edges, employee.EdgeAge)
	}
	if m.position != nil {
		edges = append(edges, employee.EdgePosition)
	}
	if m.salary != nil {
		edges = append(edges, employee.EdgeSalary)
	}
	if m.payment != nil {
		edges = append(edges, employee.EdgePayment)
	}
	if m.equipment != nil {
		edges = append(edges, employee.EdgeEquipment)
	}
	if m.bookcourse != nil {
		edges = append(edges, employee.EdgeBookcourse)
	}
	if m.equipmentrental != nil {
		edges = append(edges, employee.EdgeEquipmentrental)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAge:
		if id := m.age; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeSalary:
		if id := m.salary; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.bookcourse))
		for id := range m.bookcourse {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.equipmentrental))
		for id := range m.equipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedpayment != nil {
		edges = append(edges, employee.EdgePayment)
	}
	if m.removedequipment != nil {
		edges = append(edges, employee.EdgeEquipment)
	}
	if m.removedbookcourse != nil {
		edges = append(edges, employee.EdgeBookcourse)
	}
	if m.removedequipmentrental != nil {
		edges = append(edges, employee.EdgeEquipmentrental)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.removedbookcourse))
		for id := range m.removedbookcourse {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.removedequipmentrental))
		for id := range m.removedequipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedage {
		edges = append(edges, employee.EdgeAge)
	}
	if m.clearedposition {
		edges = append(edges, employee.EdgePosition)
	}
	if m.clearedsalary {
		edges = append(edges, employee.EdgeSalary)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeAge:
		return m.clearedage
	case employee.EdgePosition:
		return m.clearedposition
	case employee.EdgeSalary:
		return m.clearedsalary
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeAge:
		m.ClearAge()
		return nil
	case employee.EdgePosition:
		m.ClearPosition()
		return nil
	case employee.EdgeSalary:
		m.ClearSalary()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeAge:
		m.ResetAge()
		return nil
	case employee.EdgePosition:
		m.ResetPosition()
		return nil
	case employee.EdgeSalary:
		m.ResetSalary()
		return nil
	case employee.EdgePayment:
		m.ResetPayment()
		return nil
	case employee.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case employee.EdgeBookcourse:
		m.ResetBookcourse()
		return nil
	case employee.EdgeEquipmentrental:
		m.ResetEquipmentrental()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EquipmentMutation represents an operation that mutate the EquipmentSlice
// nodes in the graph.
type EquipmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_EQUIPMENTNAME         *string
	_EQUIPMENTAMOUNT       *int
	add_EQUIPMENTAMOUNT    *int
	_EQUIPMENTDETAIL       *string
	_EQUIPMENTDATE         *time.Time
	clearedFields          map[string]struct{}
	classifier             *int
	clearedclassifier      bool
	employee               *int
	clearedemployee        bool
	equipmenttype          *int
	clearedequipmenttype   bool
	zone                   *int
	clearedzone            bool
	equipmentrental        map[int]struct{}
	removedequipmentrental map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Equipment, error)
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows to manage the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for $n.Name.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the id field of the mutation.
func withEquipmentID(id int) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEQUIPMENTNAME sets the EQUIPMENTNAME field.
func (m *EquipmentMutation) SetEQUIPMENTNAME(s string) {
	m._EQUIPMENTNAME = &s
}

// EQUIPMENTNAME returns the EQUIPMENTNAME value in the mutation.
func (m *EquipmentMutation) EQUIPMENTNAME() (r string, exists bool) {
	v := m._EQUIPMENTNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTNAME returns the old EQUIPMENTNAME value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldEQUIPMENTNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTNAME: %w", err)
	}
	return oldValue.EQUIPMENTNAME, nil
}

// ResetEQUIPMENTNAME reset all changes of the "EQUIPMENTNAME" field.
func (m *EquipmentMutation) ResetEQUIPMENTNAME() {
	m._EQUIPMENTNAME = nil
}

// SetEQUIPMENTAMOUNT sets the EQUIPMENTAMOUNT field.
func (m *EquipmentMutation) SetEQUIPMENTAMOUNT(i int) {
	m._EQUIPMENTAMOUNT = &i
	m.add_EQUIPMENTAMOUNT = nil
}

// EQUIPMENTAMOUNT returns the EQUIPMENTAMOUNT value in the mutation.
func (m *EquipmentMutation) EQUIPMENTAMOUNT() (r int, exists bool) {
	v := m._EQUIPMENTAMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTAMOUNT returns the old EQUIPMENTAMOUNT value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldEQUIPMENTAMOUNT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTAMOUNT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTAMOUNT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTAMOUNT: %w", err)
	}
	return oldValue.EQUIPMENTAMOUNT, nil
}

// AddEQUIPMENTAMOUNT adds i to EQUIPMENTAMOUNT.
func (m *EquipmentMutation) AddEQUIPMENTAMOUNT(i int) {
	if m.add_EQUIPMENTAMOUNT != nil {
		*m.add_EQUIPMENTAMOUNT += i
	} else {
		m.add_EQUIPMENTAMOUNT = &i
	}
}

// AddedEQUIPMENTAMOUNT returns the value that was added to the EQUIPMENTAMOUNT field in this mutation.
func (m *EquipmentMutation) AddedEQUIPMENTAMOUNT() (r int, exists bool) {
	v := m.add_EQUIPMENTAMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// ResetEQUIPMENTAMOUNT reset all changes of the "EQUIPMENTAMOUNT" field.
func (m *EquipmentMutation) ResetEQUIPMENTAMOUNT() {
	m._EQUIPMENTAMOUNT = nil
	m.add_EQUIPMENTAMOUNT = nil
}

// SetEQUIPMENTDETAIL sets the EQUIPMENTDETAIL field.
func (m *EquipmentMutation) SetEQUIPMENTDETAIL(s string) {
	m._EQUIPMENTDETAIL = &s
}

// EQUIPMENTDETAIL returns the EQUIPMENTDETAIL value in the mutation.
func (m *EquipmentMutation) EQUIPMENTDETAIL() (r string, exists bool) {
	v := m._EQUIPMENTDETAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTDETAIL returns the old EQUIPMENTDETAIL value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldEQUIPMENTDETAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTDETAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTDETAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTDETAIL: %w", err)
	}
	return oldValue.EQUIPMENTDETAIL, nil
}

// ResetEQUIPMENTDETAIL reset all changes of the "EQUIPMENTDETAIL" field.
func (m *EquipmentMutation) ResetEQUIPMENTDETAIL() {
	m._EQUIPMENTDETAIL = nil
}

// SetEQUIPMENTDATE sets the EQUIPMENTDATE field.
func (m *EquipmentMutation) SetEQUIPMENTDATE(t time.Time) {
	m._EQUIPMENTDATE = &t
}

// EQUIPMENTDATE returns the EQUIPMENTDATE value in the mutation.
func (m *EquipmentMutation) EQUIPMENTDATE() (r time.Time, exists bool) {
	v := m._EQUIPMENTDATE
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTDATE returns the old EQUIPMENTDATE value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldEQUIPMENTDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTDATE: %w", err)
	}
	return oldValue.EQUIPMENTDATE, nil
}

// ResetEQUIPMENTDATE reset all changes of the "EQUIPMENTDATE" field.
func (m *EquipmentMutation) ResetEQUIPMENTDATE() {
	m._EQUIPMENTDATE = nil
}

// SetClassifierID sets the classifier edge to Classifier by id.
func (m *EquipmentMutation) SetClassifierID(id int) {
	m.classifier = &id
}

// ClearClassifier clears the classifier edge to Classifier.
func (m *EquipmentMutation) ClearClassifier() {
	m.clearedclassifier = true
}

// ClassifierCleared returns if the edge classifier was cleared.
func (m *EquipmentMutation) ClassifierCleared() bool {
	return m.clearedclassifier
}

// ClassifierID returns the classifier id in the mutation.
func (m *EquipmentMutation) ClassifierID() (id int, exists bool) {
	if m.classifier != nil {
		return *m.classifier, true
	}
	return
}

// ClassifierIDs returns the classifier ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClassifierID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) ClassifierIDs() (ids []int) {
	if id := m.classifier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassifier reset all changes of the "classifier" edge.
func (m *EquipmentMutation) ResetClassifier() {
	m.classifier = nil
	m.clearedclassifier = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *EquipmentMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *EquipmentMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *EquipmentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *EquipmentMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *EquipmentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetEquipmenttypeID sets the equipmenttype edge to Equipmenttype by id.
func (m *EquipmentMutation) SetEquipmenttypeID(id int) {
	m.equipmenttype = &id
}

// ClearEquipmenttype clears the equipmenttype edge to Equipmenttype.
func (m *EquipmentMutation) ClearEquipmenttype() {
	m.clearedequipmenttype = true
}

// EquipmenttypeCleared returns if the edge equipmenttype was cleared.
func (m *EquipmentMutation) EquipmenttypeCleared() bool {
	return m.clearedequipmenttype
}

// EquipmenttypeID returns the equipmenttype id in the mutation.
func (m *EquipmentMutation) EquipmenttypeID() (id int, exists bool) {
	if m.equipmenttype != nil {
		return *m.equipmenttype, true
	}
	return
}

// EquipmenttypeIDs returns the equipmenttype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmenttypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) EquipmenttypeIDs() (ids []int) {
	if id := m.equipmenttype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmenttype reset all changes of the "equipmenttype" edge.
func (m *EquipmentMutation) ResetEquipmenttype() {
	m.equipmenttype = nil
	m.clearedequipmenttype = false
}

// SetZoneID sets the zone edge to Zone by id.
func (m *EquipmentMutation) SetZoneID(id int) {
	m.zone = &id
}

// ClearZone clears the zone edge to Zone.
func (m *EquipmentMutation) ClearZone() {
	m.clearedzone = true
}

// ZoneCleared returns if the edge zone was cleared.
func (m *EquipmentMutation) ZoneCleared() bool {
	return m.clearedzone
}

// ZoneID returns the zone id in the mutation.
func (m *EquipmentMutation) ZoneID() (id int, exists bool) {
	if m.zone != nil {
		return *m.zone, true
	}
	return
}

// ZoneIDs returns the zone ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ZoneID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) ZoneIDs() (ids []int) {
	if id := m.zone; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetZone reset all changes of the "zone" edge.
func (m *EquipmentMutation) ResetZone() {
	m.zone = nil
	m.clearedzone = false
}

// AddEquipmentrentalIDs adds the equipmentrental edge to Equipmentrental by ids.
func (m *EquipmentMutation) AddEquipmentrentalIDs(ids ...int) {
	if m.equipmentrental == nil {
		m.equipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.equipmentrental[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentrentalIDs removes the equipmentrental edge to Equipmentrental by ids.
func (m *EquipmentMutation) RemoveEquipmentrentalIDs(ids ...int) {
	if m.removedequipmentrental == nil {
		m.removedequipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipmentrental[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentrental returns the removed ids of equipmentrental.
func (m *EquipmentMutation) RemovedEquipmentrentalIDs() (ids []int) {
	for id := range m.removedequipmentrental {
		ids = append(ids, id)
	}
	return
}

// EquipmentrentalIDs returns the equipmentrental ids in the mutation.
func (m *EquipmentMutation) EquipmentrentalIDs() (ids []int) {
	for id := range m.equipmentrental {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentrental reset all changes of the "equipmentrental" edge.
func (m *EquipmentMutation) ResetEquipmentrental() {
	m.equipmentrental = nil
	m.removedequipmentrental = nil
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._EQUIPMENTNAME != nil {
		fields = append(fields, equipment.FieldEQUIPMENTNAME)
	}
	if m._EQUIPMENTAMOUNT != nil {
		fields = append(fields, equipment.FieldEQUIPMENTAMOUNT)
	}
	if m._EQUIPMENTDETAIL != nil {
		fields = append(fields, equipment.FieldEQUIPMENTDETAIL)
	}
	if m._EQUIPMENTDATE != nil {
		fields = append(fields, equipment.FieldEQUIPMENTDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldEQUIPMENTNAME:
		return m.EQUIPMENTNAME()
	case equipment.FieldEQUIPMENTAMOUNT:
		return m.EQUIPMENTAMOUNT()
	case equipment.FieldEQUIPMENTDETAIL:
		return m.EQUIPMENTDETAIL()
	case equipment.FieldEQUIPMENTDATE:
		return m.EQUIPMENTDATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldEQUIPMENTNAME:
		return m.OldEQUIPMENTNAME(ctx)
	case equipment.FieldEQUIPMENTAMOUNT:
		return m.OldEQUIPMENTAMOUNT(ctx)
	case equipment.FieldEQUIPMENTDETAIL:
		return m.OldEQUIPMENTDETAIL(ctx)
	case equipment.FieldEQUIPMENTDATE:
		return m.OldEQUIPMENTDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldEQUIPMENTNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTNAME(v)
		return nil
	case equipment.FieldEQUIPMENTAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTAMOUNT(v)
		return nil
	case equipment.FieldEQUIPMENTDETAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTDETAIL(v)
		return nil
	case equipment.FieldEQUIPMENTDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	var fields []string
	if m.add_EQUIPMENTAMOUNT != nil {
		fields = append(fields, equipment.FieldEQUIPMENTAMOUNT)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldEQUIPMENTAMOUNT:
		return m.AddedEQUIPMENTAMOUNT()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldEQUIPMENTAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEQUIPMENTAMOUNT(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldEQUIPMENTNAME:
		m.ResetEQUIPMENTNAME()
		return nil
	case equipment.FieldEQUIPMENTAMOUNT:
		m.ResetEQUIPMENTAMOUNT()
		return nil
	case equipment.FieldEQUIPMENTDETAIL:
		m.ResetEQUIPMENTDETAIL()
		return nil
	case equipment.FieldEQUIPMENTDATE:
		m.ResetEQUIPMENTDATE()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.classifier != nil {
		edges = append(edges, equipment.EdgeClassifier)
	}
	if m.employee != nil {
		edges = append(edges, equipment.EdgeEmployee)
	}
	if m.equipmenttype != nil {
		edges = append(edges, equipment.EdgeEquipmenttype)
	}
	if m.zone != nil {
		edges = append(edges, equipment.EdgeZone)
	}
	if m.equipmentrental != nil {
		edges = append(edges, equipment.EdgeEquipmentrental)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeClassifier:
		if id := m.classifier; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEquipmenttype:
		if id := m.equipmenttype; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeZone:
		if id := m.zone; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.equipmentrental))
		for id := range m.equipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedequipmentrental != nil {
		edges = append(edges, equipment.EdgeEquipmentrental)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.removedequipmentrental))
		for id := range m.removedequipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedclassifier {
		edges = append(edges, equipment.EdgeClassifier)
	}
	if m.clearedemployee {
		edges = append(edges, equipment.EdgeEmployee)
	}
	if m.clearedequipmenttype {
		edges = append(edges, equipment.EdgeEquipmenttype)
	}
	if m.clearedzone {
		edges = append(edges, equipment.EdgeZone)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeClassifier:
		return m.clearedclassifier
	case equipment.EdgeEmployee:
		return m.clearedemployee
	case equipment.EdgeEquipmenttype:
		return m.clearedequipmenttype
	case equipment.EdgeZone:
		return m.clearedzone
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	case equipment.EdgeClassifier:
		m.ClearClassifier()
		return nil
	case equipment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case equipment.EdgeEquipmenttype:
		m.ClearEquipmenttype()
		return nil
	case equipment.EdgeZone:
		m.ClearZone()
		return nil
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeClassifier:
		m.ResetClassifier()
		return nil
	case equipment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case equipment.EdgeEquipmenttype:
		m.ResetEquipmenttype()
		return nil
	case equipment.EdgeZone:
		m.ResetZone()
		return nil
	case equipment.EdgeEquipmentrental:
		m.ResetEquipmentrental()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// EquipmentrentalMutation represents an operation that mutate the Equipmentrentals
// nodes in the graph.
type EquipmentrentalMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_RENTALAMOUNT        *int
	add_RENTALAMOUNT     *int
	_RENTALDATE          *time.Time
	_RETURNDATE          *time.Time
	clearedFields        map[string]struct{}
	equipment            *int
	clearedequipment     bool
	employee             *int
	clearedemployee      bool
	member               *int
	clearedmember        bool
	equipmenttype        *int
	clearedequipmenttype bool
	done                 bool
	oldValue             func(context.Context) (*Equipmentrental, error)
}

var _ ent.Mutation = (*EquipmentrentalMutation)(nil)

// equipmentrentalOption allows to manage the mutation configuration using functional options.
type equipmentrentalOption func(*EquipmentrentalMutation)

// newEquipmentrentalMutation creates new mutation for $n.Name.
func newEquipmentrentalMutation(c config, op Op, opts ...equipmentrentalOption) *EquipmentrentalMutation {
	m := &EquipmentrentalMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentrental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentrentalID sets the id field of the mutation.
func withEquipmentrentalID(id int) equipmentrentalOption {
	return func(m *EquipmentrentalMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipmentrental
		)
		m.oldValue = func(ctx context.Context) (*Equipmentrental, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipmentrental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentrental sets the old Equipmentrental of the mutation.
func withEquipmentrental(node *Equipmentrental) equipmentrentalOption {
	return func(m *EquipmentrentalMutation) {
		m.oldValue = func(context.Context) (*Equipmentrental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentrentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentrentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentrentalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRENTALAMOUNT sets the RENTALAMOUNT field.
func (m *EquipmentrentalMutation) SetRENTALAMOUNT(i int) {
	m._RENTALAMOUNT = &i
	m.add_RENTALAMOUNT = nil
}

// RENTALAMOUNT returns the RENTALAMOUNT value in the mutation.
func (m *EquipmentrentalMutation) RENTALAMOUNT() (r int, exists bool) {
	v := m._RENTALAMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// OldRENTALAMOUNT returns the old RENTALAMOUNT value of the Equipmentrental.
// If the Equipmentrental object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentrentalMutation) OldRENTALAMOUNT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRENTALAMOUNT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRENTALAMOUNT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRENTALAMOUNT: %w", err)
	}
	return oldValue.RENTALAMOUNT, nil
}

// AddRENTALAMOUNT adds i to RENTALAMOUNT.
func (m *EquipmentrentalMutation) AddRENTALAMOUNT(i int) {
	if m.add_RENTALAMOUNT != nil {
		*m.add_RENTALAMOUNT += i
	} else {
		m.add_RENTALAMOUNT = &i
	}
}

// AddedRENTALAMOUNT returns the value that was added to the RENTALAMOUNT field in this mutation.
func (m *EquipmentrentalMutation) AddedRENTALAMOUNT() (r int, exists bool) {
	v := m.add_RENTALAMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// ResetRENTALAMOUNT reset all changes of the "RENTALAMOUNT" field.
func (m *EquipmentrentalMutation) ResetRENTALAMOUNT() {
	m._RENTALAMOUNT = nil
	m.add_RENTALAMOUNT = nil
}

// SetRENTALDATE sets the RENTALDATE field.
func (m *EquipmentrentalMutation) SetRENTALDATE(t time.Time) {
	m._RENTALDATE = &t
}

// RENTALDATE returns the RENTALDATE value in the mutation.
func (m *EquipmentrentalMutation) RENTALDATE() (r time.Time, exists bool) {
	v := m._RENTALDATE
	if v == nil {
		return
	}
	return *v, true
}

// OldRENTALDATE returns the old RENTALDATE value of the Equipmentrental.
// If the Equipmentrental object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentrentalMutation) OldRENTALDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRENTALDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRENTALDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRENTALDATE: %w", err)
	}
	return oldValue.RENTALDATE, nil
}

// ResetRENTALDATE reset all changes of the "RENTALDATE" field.
func (m *EquipmentrentalMutation) ResetRENTALDATE() {
	m._RENTALDATE = nil
}

// SetRETURNDATE sets the RETURNDATE field.
func (m *EquipmentrentalMutation) SetRETURNDATE(t time.Time) {
	m._RETURNDATE = &t
}

// RETURNDATE returns the RETURNDATE value in the mutation.
func (m *EquipmentrentalMutation) RETURNDATE() (r time.Time, exists bool) {
	v := m._RETURNDATE
	if v == nil {
		return
	}
	return *v, true
}

// OldRETURNDATE returns the old RETURNDATE value of the Equipmentrental.
// If the Equipmentrental object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentrentalMutation) OldRETURNDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRETURNDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRETURNDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRETURNDATE: %w", err)
	}
	return oldValue.RETURNDATE, nil
}

// ResetRETURNDATE reset all changes of the "RETURNDATE" field.
func (m *EquipmentrentalMutation) ResetRETURNDATE() {
	m._RETURNDATE = nil
}

// SetEquipmentID sets the equipment edge to Equipment by id.
func (m *EquipmentrentalMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *EquipmentrentalMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *EquipmentrentalMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the equipment id in the mutation.
func (m *EquipmentrentalMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentrentalMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *EquipmentrentalMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *EquipmentrentalMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *EquipmentrentalMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *EquipmentrentalMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *EquipmentrentalMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *EquipmentrentalMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *EquipmentrentalMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetMemberID sets the member edge to Member by id.
func (m *EquipmentrentalMutation) SetMemberID(id int) {
	m.member = &id
}

// ClearMember clears the member edge to Member.
func (m *EquipmentrentalMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared returns if the edge member was cleared.
func (m *EquipmentrentalMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the member id in the mutation.
func (m *EquipmentrentalMutation) MemberID() (id int, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the member ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *EquipmentrentalMutation) MemberIDs() (ids []int) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember reset all changes of the "member" edge.
func (m *EquipmentrentalMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetEquipmenttypeID sets the equipmenttype edge to Equipmenttype by id.
func (m *EquipmentrentalMutation) SetEquipmenttypeID(id int) {
	m.equipmenttype = &id
}

// ClearEquipmenttype clears the equipmenttype edge to Equipmenttype.
func (m *EquipmentrentalMutation) ClearEquipmenttype() {
	m.clearedequipmenttype = true
}

// EquipmenttypeCleared returns if the edge equipmenttype was cleared.
func (m *EquipmentrentalMutation) EquipmenttypeCleared() bool {
	return m.clearedequipmenttype
}

// EquipmenttypeID returns the equipmenttype id in the mutation.
func (m *EquipmentrentalMutation) EquipmenttypeID() (id int, exists bool) {
	if m.equipmenttype != nil {
		return *m.equipmenttype, true
	}
	return
}

// EquipmenttypeIDs returns the equipmenttype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmenttypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentrentalMutation) EquipmenttypeIDs() (ids []int) {
	if id := m.equipmenttype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmenttype reset all changes of the "equipmenttype" edge.
func (m *EquipmentrentalMutation) ResetEquipmenttype() {
	m.equipmenttype = nil
	m.clearedequipmenttype = false
}

// Op returns the operation name.
func (m *EquipmentrentalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipmentrental).
func (m *EquipmentrentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentrentalMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._RENTALAMOUNT != nil {
		fields = append(fields, equipmentrental.FieldRENTALAMOUNT)
	}
	if m._RENTALDATE != nil {
		fields = append(fields, equipmentrental.FieldRENTALDATE)
	}
	if m._RETURNDATE != nil {
		fields = append(fields, equipmentrental.FieldRETURNDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentrentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		return m.RENTALAMOUNT()
	case equipmentrental.FieldRENTALDATE:
		return m.RENTALDATE()
	case equipmentrental.FieldRETURNDATE:
		return m.RETURNDATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentrentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		return m.OldRENTALAMOUNT(ctx)
	case equipmentrental.FieldRENTALDATE:
		return m.OldRENTALDATE(ctx)
	case equipmentrental.FieldRETURNDATE:
		return m.OldRETURNDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Equipmentrental field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentrentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRENTALAMOUNT(v)
		return nil
	case equipmentrental.FieldRENTALDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRENTALDATE(v)
		return nil
	case equipmentrental.FieldRETURNDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRETURNDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Equipmentrental field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentrentalMutation) AddedFields() []string {
	var fields []string
	if m.add_RENTALAMOUNT != nil {
		fields = append(fields, equipmentrental.FieldRENTALAMOUNT)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentrentalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		return m.AddedRENTALAMOUNT()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentrentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRENTALAMOUNT(v)
		return nil
	}
	return fmt.Errorf("unknown Equipmentrental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentrentalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentrentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentrentalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipmentrental nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentrentalMutation) ResetField(name string) error {
	switch name {
	case equipmentrental.FieldRENTALAMOUNT:
		m.ResetRENTALAMOUNT()
		return nil
	case equipmentrental.FieldRENTALDATE:
		m.ResetRENTALDATE()
		return nil
	case equipmentrental.FieldRETURNDATE:
		m.ResetRETURNDATE()
		return nil
	}
	return fmt.Errorf("unknown Equipmentrental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentrentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.equipment != nil {
		edges = append(edges, equipmentrental.EdgeEquipment)
	}
	if m.employee != nil {
		edges = append(edges, equipmentrental.EdgeEmployee)
	}
	if m.member != nil {
		edges = append(edges, equipmentrental.EdgeMember)
	}
	if m.equipmenttype != nil {
		edges = append(edges, equipmentrental.EdgeEquipmenttype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentrentalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentrental.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case equipmentrental.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case equipmentrental.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case equipmentrental.EdgeEquipmenttype:
		if id := m.equipmenttype; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentrentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentrentalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentrentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedequipment {
		edges = append(edges, equipmentrental.EdgeEquipment)
	}
	if m.clearedemployee {
		edges = append(edges, equipmentrental.EdgeEmployee)
	}
	if m.clearedmember {
		edges = append(edges, equipmentrental.EdgeMember)
	}
	if m.clearedequipmenttype {
		edges = append(edges, equipmentrental.EdgeEquipmenttype)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentrentalMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentrental.EdgeEquipment:
		return m.clearedequipment
	case equipmentrental.EdgeEmployee:
		return m.clearedemployee
	case equipmentrental.EdgeMember:
		return m.clearedmember
	case equipmentrental.EdgeEquipmenttype:
		return m.clearedequipmenttype
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentrentalMutation) ClearEdge(name string) error {
	switch name {
	case equipmentrental.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case equipmentrental.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case equipmentrental.EdgeMember:
		m.ClearMember()
		return nil
	case equipmentrental.EdgeEquipmenttype:
		m.ClearEquipmenttype()
		return nil
	}
	return fmt.Errorf("unknown Equipmentrental unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentrentalMutation) ResetEdge(name string) error {
	switch name {
	case equipmentrental.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case equipmentrental.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case equipmentrental.EdgeMember:
		m.ResetMember()
		return nil
	case equipmentrental.EdgeEquipmenttype:
		m.ResetEquipmenttype()
		return nil
	}
	return fmt.Errorf("unknown Equipmentrental edge %s", name)
}

// EquipmenttypeMutation represents an operation that mutate the Equipmenttypes
// nodes in the graph.
type EquipmenttypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_EQUIPMENTTYPE         *string
	clearedFields          map[string]struct{}
	equipment              map[int]struct{}
	removedequipment       map[int]struct{}
	equipmentrental        map[int]struct{}
	removedequipmentrental map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Equipmenttype, error)
}

var _ ent.Mutation = (*EquipmenttypeMutation)(nil)

// equipmenttypeOption allows to manage the mutation configuration using functional options.
type equipmenttypeOption func(*EquipmenttypeMutation)

// newEquipmenttypeMutation creates new mutation for $n.Name.
func newEquipmenttypeMutation(c config, op Op, opts ...equipmenttypeOption) *EquipmenttypeMutation {
	m := &EquipmenttypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmenttype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmenttypeID sets the id field of the mutation.
func withEquipmenttypeID(id int) equipmenttypeOption {
	return func(m *EquipmenttypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipmenttype
		)
		m.oldValue = func(ctx context.Context) (*Equipmenttype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipmenttype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmenttype sets the old Equipmenttype of the mutation.
func withEquipmenttype(node *Equipmenttype) equipmenttypeOption {
	return func(m *EquipmenttypeMutation) {
		m.oldValue = func(context.Context) (*Equipmenttype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmenttypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmenttypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmenttypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEQUIPMENTTYPE sets the EQUIPMENTTYPE field.
func (m *EquipmenttypeMutation) SetEQUIPMENTTYPE(s string) {
	m._EQUIPMENTTYPE = &s
}

// EQUIPMENTTYPE returns the EQUIPMENTTYPE value in the mutation.
func (m *EquipmenttypeMutation) EQUIPMENTTYPE() (r string, exists bool) {
	v := m._EQUIPMENTTYPE
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTTYPE returns the old EQUIPMENTTYPE value of the Equipmenttype.
// If the Equipmenttype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmenttypeMutation) OldEQUIPMENTTYPE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTTYPE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTTYPE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTTYPE: %w", err)
	}
	return oldValue.EQUIPMENTTYPE, nil
}

// ResetEQUIPMENTTYPE reset all changes of the "EQUIPMENTTYPE" field.
func (m *EquipmenttypeMutation) ResetEQUIPMENTTYPE() {
	m._EQUIPMENTTYPE = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *EquipmenttypeMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *EquipmenttypeMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *EquipmenttypeMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *EquipmenttypeMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *EquipmenttypeMutation) ResetEquipment() {
	m.equipment = nil
	m.removedequipment = nil
}

// AddEquipmentrentalIDs adds the equipmentrental edge to Equipmentrental by ids.
func (m *EquipmenttypeMutation) AddEquipmentrentalIDs(ids ...int) {
	if m.equipmentrental == nil {
		m.equipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.equipmentrental[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentrentalIDs removes the equipmentrental edge to Equipmentrental by ids.
func (m *EquipmenttypeMutation) RemoveEquipmentrentalIDs(ids ...int) {
	if m.removedequipmentrental == nil {
		m.removedequipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipmentrental[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentrental returns the removed ids of equipmentrental.
func (m *EquipmenttypeMutation) RemovedEquipmentrentalIDs() (ids []int) {
	for id := range m.removedequipmentrental {
		ids = append(ids, id)
	}
	return
}

// EquipmentrentalIDs returns the equipmentrental ids in the mutation.
func (m *EquipmenttypeMutation) EquipmentrentalIDs() (ids []int) {
	for id := range m.equipmentrental {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentrental reset all changes of the "equipmentrental" edge.
func (m *EquipmenttypeMutation) ResetEquipmentrental() {
	m.equipmentrental = nil
	m.removedequipmentrental = nil
}

// Op returns the operation name.
func (m *EquipmenttypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipmenttype).
func (m *EquipmenttypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmenttypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._EQUIPMENTTYPE != nil {
		fields = append(fields, equipmenttype.FieldEQUIPMENTTYPE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmenttypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldEQUIPMENTTYPE:
		return m.EQUIPMENTTYPE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmenttypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmenttype.FieldEQUIPMENTTYPE:
		return m.OldEQUIPMENTTYPE(ctx)
	}
	return nil, fmt.Errorf("unknown Equipmenttype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmenttypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldEQUIPMENTTYPE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTTYPE(v)
		return nil
	}
	return fmt.Errorf("unknown Equipmenttype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmenttypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmenttypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmenttypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipmenttype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmenttypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmenttypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmenttypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipmenttype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmenttypeMutation) ResetField(name string) error {
	switch name {
	case equipmenttype.FieldEQUIPMENTTYPE:
		m.ResetEQUIPMENTTYPE()
		return nil
	}
	return fmt.Errorf("unknown Equipmenttype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmenttypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.equipment != nil {
		edges = append(edges, equipmenttype.EdgeEquipment)
	}
	if m.equipmentrental != nil {
		edges = append(edges, equipmenttype.EdgeEquipmentrental)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmenttypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.equipmentrental))
		for id := range m.equipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmenttypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedequipment != nil {
		edges = append(edges, equipmenttype.EdgeEquipment)
	}
	if m.removedequipmentrental != nil {
		edges = append(edges, equipmenttype.EdgeEquipmentrental)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmenttypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.removedequipmentrental))
		for id := range m.removedequipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmenttypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmenttypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmenttypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipmenttype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmenttypeMutation) ResetEdge(name string) error {
	switch name {
	case equipmenttype.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case equipmenttype.EdgeEquipmentrental:
		m.ResetEquipmentrental()
		return nil
	}
	return fmt.Errorf("unknown Equipmenttype edge %s", name)
}

// MemberMutation represents an operation that mutate the Members
// nodes in the graph.
type MemberMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_MEMBERID              *string
	_MEMBERNAME            *string
	clearedFields          map[string]struct{}
	payment                map[int]struct{}
	removedpayment         map[int]struct{}
	bookcourse             map[int]struct{}
	removedbookcourse      map[int]struct{}
	equipmentrental        map[int]struct{}
	removedequipmentrental map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Member, error)
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows to manage the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for $n.Name.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the id field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMEMBERID sets the MEMBERID field.
func (m *MemberMutation) SetMEMBERID(s string) {
	m._MEMBERID = &s
}

// MEMBERID returns the MEMBERID value in the mutation.
func (m *MemberMutation) MEMBERID() (r string, exists bool) {
	v := m._MEMBERID
	if v == nil {
		return
	}
	return *v, true
}

// OldMEMBERID returns the old MEMBERID value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldMEMBERID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMEMBERID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMEMBERID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMEMBERID: %w", err)
	}
	return oldValue.MEMBERID, nil
}

// ResetMEMBERID reset all changes of the "MEMBERID" field.
func (m *MemberMutation) ResetMEMBERID() {
	m._MEMBERID = nil
}

// SetMEMBERNAME sets the MEMBERNAME field.
func (m *MemberMutation) SetMEMBERNAME(s string) {
	m._MEMBERNAME = &s
}

// MEMBERNAME returns the MEMBERNAME value in the mutation.
func (m *MemberMutation) MEMBERNAME() (r string, exists bool) {
	v := m._MEMBERNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldMEMBERNAME returns the old MEMBERNAME value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldMEMBERNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMEMBERNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMEMBERNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMEMBERNAME: %w", err)
	}
	return oldValue.MEMBERNAME, nil
}

// ResetMEMBERNAME reset all changes of the "MEMBERNAME" field.
func (m *MemberMutation) ResetMEMBERNAME() {
	m._MEMBERNAME = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *MemberMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *MemberMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *MemberMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *MemberMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *MemberMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// AddBookcourseIDs adds the bookcourse edge to Bookcourse by ids.
func (m *MemberMutation) AddBookcourseIDs(ids ...int) {
	if m.bookcourse == nil {
		m.bookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.bookcourse[ids[i]] = struct{}{}
	}
}

// RemoveBookcourseIDs removes the bookcourse edge to Bookcourse by ids.
func (m *MemberMutation) RemoveBookcourseIDs(ids ...int) {
	if m.removedbookcourse == nil {
		m.removedbookcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbookcourse[ids[i]] = struct{}{}
	}
}

// RemovedBookcourse returns the removed ids of bookcourse.
func (m *MemberMutation) RemovedBookcourseIDs() (ids []int) {
	for id := range m.removedbookcourse {
		ids = append(ids, id)
	}
	return
}

// BookcourseIDs returns the bookcourse ids in the mutation.
func (m *MemberMutation) BookcourseIDs() (ids []int) {
	for id := range m.bookcourse {
		ids = append(ids, id)
	}
	return
}

// ResetBookcourse reset all changes of the "bookcourse" edge.
func (m *MemberMutation) ResetBookcourse() {
	m.bookcourse = nil
	m.removedbookcourse = nil
}

// AddEquipmentrentalIDs adds the equipmentrental edge to Equipmentrental by ids.
func (m *MemberMutation) AddEquipmentrentalIDs(ids ...int) {
	if m.equipmentrental == nil {
		m.equipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.equipmentrental[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentrentalIDs removes the equipmentrental edge to Equipmentrental by ids.
func (m *MemberMutation) RemoveEquipmentrentalIDs(ids ...int) {
	if m.removedequipmentrental == nil {
		m.removedequipmentrental = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipmentrental[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentrental returns the removed ids of equipmentrental.
func (m *MemberMutation) RemovedEquipmentrentalIDs() (ids []int) {
	for id := range m.removedequipmentrental {
		ids = append(ids, id)
	}
	return
}

// EquipmentrentalIDs returns the equipmentrental ids in the mutation.
func (m *MemberMutation) EquipmentrentalIDs() (ids []int) {
	for id := range m.equipmentrental {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentrental reset all changes of the "equipmentrental" edge.
func (m *MemberMutation) ResetEquipmentrental() {
	m.equipmentrental = nil
	m.removedequipmentrental = nil
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._MEMBERID != nil {
		fields = append(fields, member.FieldMEMBERID)
	}
	if m._MEMBERNAME != nil {
		fields = append(fields, member.FieldMEMBERNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldMEMBERID:
		return m.MEMBERID()
	case member.FieldMEMBERNAME:
		return m.MEMBERNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldMEMBERID:
		return m.OldMEMBERID(ctx)
	case member.FieldMEMBERNAME:
		return m.OldMEMBERNAME(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldMEMBERID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMEMBERID(v)
		return nil
	case member.FieldMEMBERNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMEMBERNAME(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldMEMBERID:
		m.ResetMEMBERID()
		return nil
	case member.FieldMEMBERNAME:
		m.ResetMEMBERNAME()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.payment != nil {
		edges = append(edges, member.EdgePayment)
	}
	if m.bookcourse != nil {
		edges = append(edges, member.EdgeBookcourse)
	}
	if m.equipmentrental != nil {
		edges = append(edges, member.EdgeEquipmentrental)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.bookcourse))
		for id := range m.bookcourse {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.equipmentrental))
		for id := range m.equipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpayment != nil {
		edges = append(edges, member.EdgePayment)
	}
	if m.removedbookcourse != nil {
		edges = append(edges, member.EdgeBookcourse)
	}
	if m.removedequipmentrental != nil {
		edges = append(edges, member.EdgeEquipmentrental)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeBookcourse:
		ids := make([]ent.Value, 0, len(m.removedbookcourse))
		for id := range m.removedbookcourse {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeEquipmentrental:
		ids := make([]ent.Value, 0, len(m.removedequipmentrental))
		for id := range m.removedequipmentrental {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgePayment:
		m.ResetPayment()
		return nil
	case member.EdgeBookcourse:
		m.ResetBookcourse()
		return nil
	case member.EdgeEquipmentrental:
		m.ResetEquipmentrental()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_PAYMENTAMOUNT     *string
	_PAYMENTDATE       *time.Time
	clearedFields      map[string]struct{}
	member             *int
	clearedmember      bool
	employee           *int
	clearedemployee    bool
	paymenttype        *int
	clearedpaymenttype bool
	promotion          *int
	clearedpromotion   bool
	done               bool
	oldValue           func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPAYMENTAMOUNT sets the PAYMENTAMOUNT field.
func (m *PaymentMutation) SetPAYMENTAMOUNT(s string) {
	m._PAYMENTAMOUNT = &s
}

// PAYMENTAMOUNT returns the PAYMENTAMOUNT value in the mutation.
func (m *PaymentMutation) PAYMENTAMOUNT() (r string, exists bool) {
	v := m._PAYMENTAMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// OldPAYMENTAMOUNT returns the old PAYMENTAMOUNT value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPAYMENTAMOUNT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPAYMENTAMOUNT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPAYMENTAMOUNT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPAYMENTAMOUNT: %w", err)
	}
	return oldValue.PAYMENTAMOUNT, nil
}

// ResetPAYMENTAMOUNT reset all changes of the "PAYMENTAMOUNT" field.
func (m *PaymentMutation) ResetPAYMENTAMOUNT() {
	m._PAYMENTAMOUNT = nil
}

// SetPAYMENTDATE sets the PAYMENTDATE field.
func (m *PaymentMutation) SetPAYMENTDATE(t time.Time) {
	m._PAYMENTDATE = &t
}

// PAYMENTDATE returns the PAYMENTDATE value in the mutation.
func (m *PaymentMutation) PAYMENTDATE() (r time.Time, exists bool) {
	v := m._PAYMENTDATE
	if v == nil {
		return
	}
	return *v, true
}

// OldPAYMENTDATE returns the old PAYMENTDATE value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPAYMENTDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPAYMENTDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPAYMENTDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPAYMENTDATE: %w", err)
	}
	return oldValue.PAYMENTDATE, nil
}

// ResetPAYMENTDATE reset all changes of the "PAYMENTDATE" field.
func (m *PaymentMutation) ResetPAYMENTDATE() {
	m._PAYMENTDATE = nil
}

// SetMemberID sets the member edge to Member by id.
func (m *PaymentMutation) SetMemberID(id int) {
	m.member = &id
}

// ClearMember clears the member edge to Member.
func (m *PaymentMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared returns if the edge member was cleared.
func (m *PaymentMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the member id in the mutation.
func (m *PaymentMutation) MemberID() (id int, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the member ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) MemberIDs() (ids []int) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember reset all changes of the "member" edge.
func (m *PaymentMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *PaymentMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *PaymentMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *PaymentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *PaymentMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PaymentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPaymenttypeID sets the paymenttype edge to Paymenttype by id.
func (m *PaymentMutation) SetPaymenttypeID(id int) {
	m.paymenttype = &id
}

// ClearPaymenttype clears the paymenttype edge to Paymenttype.
func (m *PaymentMutation) ClearPaymenttype() {
	m.clearedpaymenttype = true
}

// PaymenttypeCleared returns if the edge paymenttype was cleared.
func (m *PaymentMutation) PaymenttypeCleared() bool {
	return m.clearedpaymenttype
}

// PaymenttypeID returns the paymenttype id in the mutation.
func (m *PaymentMutation) PaymenttypeID() (id int, exists bool) {
	if m.paymenttype != nil {
		return *m.paymenttype, true
	}
	return
}

// PaymenttypeIDs returns the paymenttype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymenttypeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) PaymenttypeIDs() (ids []int) {
	if id := m.paymenttype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymenttype reset all changes of the "paymenttype" edge.
func (m *PaymentMutation) ResetPaymenttype() {
	m.paymenttype = nil
	m.clearedpaymenttype = false
}

// SetPromotionID sets the promotion edge to Promotion by id.
func (m *PaymentMutation) SetPromotionID(id int) {
	m.promotion = &id
}

// ClearPromotion clears the promotion edge to Promotion.
func (m *PaymentMutation) ClearPromotion() {
	m.clearedpromotion = true
}

// PromotionCleared returns if the edge promotion was cleared.
func (m *PaymentMutation) PromotionCleared() bool {
	return m.clearedpromotion
}

// PromotionID returns the promotion id in the mutation.
func (m *PaymentMutation) PromotionID() (id int, exists bool) {
	if m.promotion != nil {
		return *m.promotion, true
	}
	return
}

// PromotionIDs returns the promotion ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PromotionID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) PromotionIDs() (ids []int) {
	if id := m.promotion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotion reset all changes of the "promotion" edge.
func (m *PaymentMutation) ResetPromotion() {
	m.promotion = nil
	m.clearedpromotion = false
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._PAYMENTAMOUNT != nil {
		fields = append(fields, payment.FieldPAYMENTAMOUNT)
	}
	if m._PAYMENTDATE != nil {
		fields = append(fields, payment.FieldPAYMENTDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldPAYMENTAMOUNT:
		return m.PAYMENTAMOUNT()
	case payment.FieldPAYMENTDATE:
		return m.PAYMENTDATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldPAYMENTAMOUNT:
		return m.OldPAYMENTAMOUNT(ctx)
	case payment.FieldPAYMENTDATE:
		return m.OldPAYMENTDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldPAYMENTAMOUNT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPAYMENTAMOUNT(v)
		return nil
	case payment.FieldPAYMENTDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPAYMENTDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldPAYMENTAMOUNT:
		m.ResetPAYMENTAMOUNT()
		return nil
	case payment.FieldPAYMENTDATE:
		m.ResetPAYMENTDATE()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.member != nil {
		edges = append(edges, payment.EdgeMember)
	}
	if m.employee != nil {
		edges = append(edges, payment.EdgeEmployee)
	}
	if m.paymenttype != nil {
		edges = append(edges, payment.EdgePaymenttype)
	}
	if m.promotion != nil {
		edges = append(edges, payment.EdgePromotion)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePaymenttype:
		if id := m.paymenttype; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePromotion:
		if id := m.promotion; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmember {
		edges = append(edges, payment.EdgeMember)
	}
	if m.clearedemployee {
		edges = append(edges, payment.EdgeEmployee)
	}
	if m.clearedpaymenttype {
		edges = append(edges, payment.EdgePaymenttype)
	}
	if m.clearedpromotion {
		edges = append(edges, payment.EdgePromotion)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeMember:
		return m.clearedmember
	case payment.EdgeEmployee:
		return m.clearedemployee
	case payment.EdgePaymenttype:
		return m.clearedpaymenttype
	case payment.EdgePromotion:
		return m.clearedpromotion
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeMember:
		m.ClearMember()
		return nil
	case payment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case payment.EdgePaymenttype:
		m.ClearPaymenttype()
		return nil
	case payment.EdgePromotion:
		m.ClearPromotion()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeMember:
		m.ResetMember()
		return nil
	case payment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case payment.EdgePaymenttype:
		m.ResetPaymenttype()
		return nil
	case payment.EdgePromotion:
		m.ResetPromotion()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymenttypeMutation represents an operation that mutate the Paymenttypes
// nodes in the graph.
type PaymenttypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_TYPE          *string
	clearedFields  map[string]struct{}
	payment        map[int]struct{}
	removedpayment map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Paymenttype, error)
}

var _ ent.Mutation = (*PaymenttypeMutation)(nil)

// paymenttypeOption allows to manage the mutation configuration using functional options.
type paymenttypeOption func(*PaymenttypeMutation)

// newPaymenttypeMutation creates new mutation for $n.Name.
func newPaymenttypeMutation(c config, op Op, opts ...paymenttypeOption) *PaymenttypeMutation {
	m := &PaymenttypeMutation{
		config:        c,
		op:            op,
		typ:           TypePaymenttype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymenttypeID sets the id field of the mutation.
func withPaymenttypeID(id int) paymenttypeOption {
	return func(m *PaymenttypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Paymenttype
		)
		m.oldValue = func(ctx context.Context) (*Paymenttype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Paymenttype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymenttype sets the old Paymenttype of the mutation.
func withPaymenttype(node *Paymenttype) paymenttypeOption {
	return func(m *PaymenttypeMutation) {
		m.oldValue = func(context.Context) (*Paymenttype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymenttypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymenttypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymenttypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTYPE sets the TYPE field.
func (m *PaymenttypeMutation) SetTYPE(s string) {
	m._TYPE = &s
}

// TYPE returns the TYPE value in the mutation.
func (m *PaymenttypeMutation) TYPE() (r string, exists bool) {
	v := m._TYPE
	if v == nil {
		return
	}
	return *v, true
}

// OldTYPE returns the old TYPE value of the Paymenttype.
// If the Paymenttype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymenttypeMutation) OldTYPE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTYPE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTYPE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTYPE: %w", err)
	}
	return oldValue.TYPE, nil
}

// ResetTYPE reset all changes of the "TYPE" field.
func (m *PaymenttypeMutation) ResetTYPE() {
	m._TYPE = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *PaymenttypeMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *PaymenttypeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *PaymenttypeMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *PaymenttypeMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *PaymenttypeMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *PaymenttypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Paymenttype).
func (m *PaymenttypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymenttypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TYPE != nil {
		fields = append(fields, paymenttype.FieldTYPE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymenttypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenttype.FieldTYPE:
		return m.TYPE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymenttypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenttype.FieldTYPE:
		return m.OldTYPE(ctx)
	}
	return nil, fmt.Errorf("unknown Paymenttype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymenttypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenttype.FieldTYPE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTYPE(v)
		return nil
	}
	return fmt.Errorf("unknown Paymenttype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymenttypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymenttypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymenttypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Paymenttype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymenttypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymenttypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymenttypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Paymenttype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymenttypeMutation) ResetField(name string) error {
	switch name {
	case paymenttype.FieldTYPE:
		m.ResetTYPE()
		return nil
	}
	return fmt.Errorf("unknown Paymenttype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymenttypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymenttype.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymenttypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenttype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymenttypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayment != nil {
		edges = append(edges, paymenttype.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymenttypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymenttype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymenttypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymenttypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymenttypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Paymenttype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymenttypeMutation) ResetEdge(name string) error {
	switch name {
	case paymenttype.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Paymenttype edge %s", name)
}

// PositionMutation represents an operation that mutate the Positions
// nodes in the graph.
type PositionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_POSITION       *string
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Position, error)
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows to manage the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for $n.Name.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the id field of the mutation.
func withPositionID(id int) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPOSITION sets the POSITION field.
func (m *PositionMutation) SetPOSITION(s string) {
	m._POSITION = &s
}

// POSITION returns the POSITION value in the mutation.
func (m *PositionMutation) POSITION() (r string, exists bool) {
	v := m._POSITION
	if v == nil {
		return
	}
	return *v, true
}

// OldPOSITION returns the old POSITION value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldPOSITION(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPOSITION is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPOSITION requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPOSITION: %w", err)
	}
	return oldValue.POSITION, nil
}

// ResetPOSITION reset all changes of the "POSITION" field.
func (m *PositionMutation) ResetPOSITION() {
	m._POSITION = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *PositionMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *PositionMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *PositionMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *PositionMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PositionMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._POSITION != nil {
		fields = append(fields, position.FieldPOSITION)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldPOSITION:
		return m.POSITION()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldPOSITION:
		return m.OldPOSITION(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldPOSITION:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPOSITION(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldPOSITION:
		m.ResetPOSITION()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, position.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, position.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// PromotionMutation represents an operation that mutate the Promotions
// nodes in the graph.
type PromotionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_NAME                  *string
	_DESC                  *string
	_CODE                  *string
	_DATE                  *time.Time
	clearedFields          map[string]struct{}
	promotiontype          *int
	clearedpromotiontype   bool
	promotionamount        *int
	clearedpromotionamount bool
	payment                map[int]struct{}
	removedpayment         map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Promotion, error)
}

var _ ent.Mutation = (*PromotionMutation)(nil)

// promotionOption allows to manage the mutation configuration using functional options.
type promotionOption func(*PromotionMutation)

// newPromotionMutation creates new mutation for $n.Name.
func newPromotionMutation(c config, op Op, opts ...promotionOption) *PromotionMutation {
	m := &PromotionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionID sets the id field of the mutation.
func withPromotionID(id int) promotionOption {
	return func(m *PromotionMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotion
		)
		m.oldValue = func(ctx context.Context) (*Promotion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotion sets the old Promotion of the mutation.
func withPromotion(node *Promotion) promotionOption {
	return func(m *PromotionMutation) {
		m.oldValue = func(context.Context) (*Promotion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PromotionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNAME sets the NAME field.
func (m *PromotionMutation) SetNAME(s string) {
	m._NAME = &s
}

// NAME returns the NAME value in the mutation.
func (m *PromotionMutation) NAME() (r string, exists bool) {
	v := m._NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldNAME returns the old NAME value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNAME: %w", err)
	}
	return oldValue.NAME, nil
}

// ResetNAME reset all changes of the "NAME" field.
func (m *PromotionMutation) ResetNAME() {
	m._NAME = nil
}

// SetDESC sets the DESC field.
func (m *PromotionMutation) SetDESC(s string) {
	m._DESC = &s
}

// DESC returns the DESC value in the mutation.
func (m *PromotionMutation) DESC() (r string, exists bool) {
	v := m._DESC
	if v == nil {
		return
	}
	return *v, true
}

// OldDESC returns the old DESC value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldDESC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDESC is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDESC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDESC: %w", err)
	}
	return oldValue.DESC, nil
}

// ResetDESC reset all changes of the "DESC" field.
func (m *PromotionMutation) ResetDESC() {
	m._DESC = nil
}

// SetCODE sets the CODE field.
func (m *PromotionMutation) SetCODE(s string) {
	m._CODE = &s
}

// CODE returns the CODE value in the mutation.
func (m *PromotionMutation) CODE() (r string, exists bool) {
	v := m._CODE
	if v == nil {
		return
	}
	return *v, true
}

// OldCODE returns the old CODE value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldCODE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCODE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCODE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCODE: %w", err)
	}
	return oldValue.CODE, nil
}

// ResetCODE reset all changes of the "CODE" field.
func (m *PromotionMutation) ResetCODE() {
	m._CODE = nil
}

// SetDATE sets the DATE field.
func (m *PromotionMutation) SetDATE(t time.Time) {
	m._DATE = &t
}

// DATE returns the DATE value in the mutation.
func (m *PromotionMutation) DATE() (r time.Time, exists bool) {
	v := m._DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldDATE returns the old DATE value of the Promotion.
// If the Promotion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionMutation) OldDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDATE: %w", err)
	}
	return oldValue.DATE, nil
}

// ResetDATE reset all changes of the "DATE" field.
func (m *PromotionMutation) ResetDATE() {
	m._DATE = nil
}

// SetPromotiontypeID sets the promotiontype edge to Promotiontype by id.
func (m *PromotionMutation) SetPromotiontypeID(id int) {
	m.promotiontype = &id
}

// ClearPromotiontype clears the promotiontype edge to Promotiontype.
func (m *PromotionMutation) ClearPromotiontype() {
	m.clearedpromotiontype = true
}

// PromotiontypeCleared returns if the edge promotiontype was cleared.
func (m *PromotionMutation) PromotiontypeCleared() bool {
	return m.clearedpromotiontype
}

// PromotiontypeID returns the promotiontype id in the mutation.
func (m *PromotionMutation) PromotiontypeID() (id int, exists bool) {
	if m.promotiontype != nil {
		return *m.promotiontype, true
	}
	return
}

// PromotiontypeIDs returns the promotiontype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PromotiontypeID instead. It exists only for internal usage by the builders.
func (m *PromotionMutation) PromotiontypeIDs() (ids []int) {
	if id := m.promotiontype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotiontype reset all changes of the "promotiontype" edge.
func (m *PromotionMutation) ResetPromotiontype() {
	m.promotiontype = nil
	m.clearedpromotiontype = false
}

// SetPromotionamountID sets the promotionamount edge to Promotionamount by id.
func (m *PromotionMutation) SetPromotionamountID(id int) {
	m.promotionamount = &id
}

// ClearPromotionamount clears the promotionamount edge to Promotionamount.
func (m *PromotionMutation) ClearPromotionamount() {
	m.clearedpromotionamount = true
}

// PromotionamountCleared returns if the edge promotionamount was cleared.
func (m *PromotionMutation) PromotionamountCleared() bool {
	return m.clearedpromotionamount
}

// PromotionamountID returns the promotionamount id in the mutation.
func (m *PromotionMutation) PromotionamountID() (id int, exists bool) {
	if m.promotionamount != nil {
		return *m.promotionamount, true
	}
	return
}

// PromotionamountIDs returns the promotionamount ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PromotionamountID instead. It exists only for internal usage by the builders.
func (m *PromotionMutation) PromotionamountIDs() (ids []int) {
	if id := m.promotionamount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotionamount reset all changes of the "promotionamount" edge.
func (m *PromotionMutation) ResetPromotionamount() {
	m.promotionamount = nil
	m.clearedpromotionamount = false
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *PromotionMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *PromotionMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *PromotionMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *PromotionMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *PromotionMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *PromotionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotion).
func (m *PromotionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PromotionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._NAME != nil {
		fields = append(fields, promotion.FieldNAME)
	}
	if m._DESC != nil {
		fields = append(fields, promotion.FieldDESC)
	}
	if m._CODE != nil {
		fields = append(fields, promotion.FieldCODE)
	}
	if m._DATE != nil {
		fields = append(fields, promotion.FieldDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PromotionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldNAME:
		return m.NAME()
	case promotion.FieldDESC:
		return m.DESC()
	case promotion.FieldCODE:
		return m.CODE()
	case promotion.FieldDATE:
		return m.DATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PromotionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotion.FieldNAME:
		return m.OldNAME(ctx)
	case promotion.FieldDESC:
		return m.OldDESC(ctx)
	case promotion.FieldCODE:
		return m.OldCODE(ctx)
	case promotion.FieldDATE:
		return m.OldDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Promotion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNAME(v)
		return nil
	case promotion.FieldDESC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDESC(v)
		return nil
	case promotion.FieldCODE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCODE(v)
		return nil
	case promotion.FieldDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PromotionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PromotionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PromotionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PromotionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Promotion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PromotionMutation) ResetField(name string) error {
	switch name {
	case promotion.FieldNAME:
		m.ResetNAME()
		return nil
	case promotion.FieldDESC:
		m.ResetDESC()
		return nil
	case promotion.FieldCODE:
		m.ResetCODE()
		return nil
	case promotion.FieldDATE:
		m.ResetDATE()
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PromotionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.promotiontype != nil {
		edges = append(edges, promotion.EdgePromotiontype)
	}
	if m.promotionamount != nil {
		edges = append(edges, promotion.EdgePromotionamount)
	}
	if m.payment != nil {
		edges = append(edges, promotion.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PromotionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotion.EdgePromotiontype:
		if id := m.promotiontype; id != nil {
			return []ent.Value{*id}
		}
	case promotion.EdgePromotionamount:
		if id := m.promotionamount; id != nil {
			return []ent.Value{*id}
		}
	case promotion.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PromotionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpayment != nil {
		edges = append(edges, promotion.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PromotionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotion.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PromotionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpromotiontype {
		edges = append(edges, promotion.EdgePromotiontype)
	}
	if m.clearedpromotionamount {
		edges = append(edges, promotion.EdgePromotionamount)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PromotionMutation) EdgeCleared(name string) bool {
	switch name {
	case promotion.EdgePromotiontype:
		return m.clearedpromotiontype
	case promotion.EdgePromotionamount:
		return m.clearedpromotionamount
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PromotionMutation) ClearEdge(name string) error {
	switch name {
	case promotion.EdgePromotiontype:
		m.ClearPromotiontype()
		return nil
	case promotion.EdgePromotionamount:
		m.ClearPromotionamount()
		return nil
	}
	return fmt.Errorf("unknown Promotion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PromotionMutation) ResetEdge(name string) error {
	switch name {
	case promotion.EdgePromotiontype:
		m.ResetPromotiontype()
		return nil
	case promotion.EdgePromotionamount:
		m.ResetPromotionamount()
		return nil
	case promotion.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Promotion edge %s", name)
}

// PromotionamountMutation represents an operation that mutate the Promotionamounts
// nodes in the graph.
type PromotionamountMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_AMOUNT          *int
	add_AMOUNT       *int
	clearedFields    map[string]struct{}
	promotion        map[int]struct{}
	removedpromotion map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Promotionamount, error)
}

var _ ent.Mutation = (*PromotionamountMutation)(nil)

// promotionamountOption allows to manage the mutation configuration using functional options.
type promotionamountOption func(*PromotionamountMutation)

// newPromotionamountMutation creates new mutation for $n.Name.
func newPromotionamountMutation(c config, op Op, opts ...promotionamountOption) *PromotionamountMutation {
	m := &PromotionamountMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionamount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionamountID sets the id field of the mutation.
func withPromotionamountID(id int) promotionamountOption {
	return func(m *PromotionamountMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotionamount
		)
		m.oldValue = func(ctx context.Context) (*Promotionamount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotionamount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionamount sets the old Promotionamount of the mutation.
func withPromotionamount(node *Promotionamount) promotionamountOption {
	return func(m *PromotionamountMutation) {
		m.oldValue = func(context.Context) (*Promotionamount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionamountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionamountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PromotionamountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAMOUNT sets the AMOUNT field.
func (m *PromotionamountMutation) SetAMOUNT(i int) {
	m._AMOUNT = &i
	m.add_AMOUNT = nil
}

// AMOUNT returns the AMOUNT value in the mutation.
func (m *PromotionamountMutation) AMOUNT() (r int, exists bool) {
	v := m._AMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// OldAMOUNT returns the old AMOUNT value of the Promotionamount.
// If the Promotionamount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotionamountMutation) OldAMOUNT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAMOUNT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAMOUNT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAMOUNT: %w", err)
	}
	return oldValue.AMOUNT, nil
}

// AddAMOUNT adds i to AMOUNT.
func (m *PromotionamountMutation) AddAMOUNT(i int) {
	if m.add_AMOUNT != nil {
		*m.add_AMOUNT += i
	} else {
		m.add_AMOUNT = &i
	}
}

// AddedAMOUNT returns the value that was added to the AMOUNT field in this mutation.
func (m *PromotionamountMutation) AddedAMOUNT() (r int, exists bool) {
	v := m.add_AMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// ResetAMOUNT reset all changes of the "AMOUNT" field.
func (m *PromotionamountMutation) ResetAMOUNT() {
	m._AMOUNT = nil
	m.add_AMOUNT = nil
}

// AddPromotionIDs adds the promotion edge to Promotion by ids.
func (m *PromotionamountMutation) AddPromotionIDs(ids ...int) {
	if m.promotion == nil {
		m.promotion = make(map[int]struct{})
	}
	for i := range ids {
		m.promotion[ids[i]] = struct{}{}
	}
}

// RemovePromotionIDs removes the promotion edge to Promotion by ids.
func (m *PromotionamountMutation) RemovePromotionIDs(ids ...int) {
	if m.removedpromotion == nil {
		m.removedpromotion = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpromotion[ids[i]] = struct{}{}
	}
}

// RemovedPromotion returns the removed ids of promotion.
func (m *PromotionamountMutation) RemovedPromotionIDs() (ids []int) {
	for id := range m.removedpromotion {
		ids = append(ids, id)
	}
	return
}

// PromotionIDs returns the promotion ids in the mutation.
func (m *PromotionamountMutation) PromotionIDs() (ids []int) {
	for id := range m.promotion {
		ids = append(ids, id)
	}
	return
}

// ResetPromotion reset all changes of the "promotion" edge.
func (m *PromotionamountMutation) ResetPromotion() {
	m.promotion = nil
	m.removedpromotion = nil
}

// Op returns the operation name.
func (m *PromotionamountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotionamount).
func (m *PromotionamountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PromotionamountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AMOUNT != nil {
		fields = append(fields, promotionamount.FieldAMOUNT)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PromotionamountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionamount.FieldAMOUNT:
		return m.AMOUNT()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PromotionamountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionamount.FieldAMOUNT:
		return m.OldAMOUNT(ctx)
	}
	return nil, fmt.Errorf("unknown Promotionamount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionamountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionamount.FieldAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAMOUNT(v)
		return nil
	}
	return fmt.Errorf("unknown Promotionamount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PromotionamountMutation) AddedFields() []string {
	var fields []string
	if m.add_AMOUNT != nil {
		fields = append(fields, promotionamount.FieldAMOUNT)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PromotionamountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionamount.FieldAMOUNT:
		return m.AddedAMOUNT()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotionamountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionamount.FieldAMOUNT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAMOUNT(v)
		return nil
	}
	return fmt.Errorf("unknown Promotionamount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PromotionamountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PromotionamountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionamountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Promotionamount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PromotionamountMutation) ResetField(name string) error {
	switch name {
	case promotionamount.FieldAMOUNT:
		m.ResetAMOUNT()
		return nil
	}
	return fmt.Errorf("unknown Promotionamount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PromotionamountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.promotion != nil {
		edges = append(edges, promotionamount.EdgePromotion)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PromotionamountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionamount.EdgePromotion:
		ids := make([]ent.Value, 0, len(m.promotion))
		for id := range m.promotion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PromotionamountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpromotion != nil {
		edges = append(edges, promotionamount.EdgePromotion)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PromotionamountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotionamount.EdgePromotion:
		ids := make([]ent.Value, 0, len(m.removedpromotion))
		for id := range m.removedpromotion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PromotionamountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PromotionamountMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PromotionamountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotionamount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PromotionamountMutation) ResetEdge(name string) error {
	switch name {
	case promotionamount.EdgePromotion:
		m.ResetPromotion()
		return nil
	}
	return fmt.Errorf("unknown Promotionamount edge %s", name)
}

// PromotiontypeMutation represents an operation that mutate the Promotiontypes
// nodes in the graph.
type PromotiontypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_TYPE            *string
	clearedFields    map[string]struct{}
	promotion        map[int]struct{}
	removedpromotion map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Promotiontype, error)
}

var _ ent.Mutation = (*PromotiontypeMutation)(nil)

// promotiontypeOption allows to manage the mutation configuration using functional options.
type promotiontypeOption func(*PromotiontypeMutation)

// newPromotiontypeMutation creates new mutation for $n.Name.
func newPromotiontypeMutation(c config, op Op, opts ...promotiontypeOption) *PromotiontypeMutation {
	m := &PromotiontypeMutation{
		config:        c,
		op:            op,
		typ:           TypePromotiontype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotiontypeID sets the id field of the mutation.
func withPromotiontypeID(id int) promotiontypeOption {
	return func(m *PromotiontypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotiontype
		)
		m.oldValue = func(ctx context.Context) (*Promotiontype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotiontype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotiontype sets the old Promotiontype of the mutation.
func withPromotiontype(node *Promotiontype) promotiontypeOption {
	return func(m *PromotiontypeMutation) {
		m.oldValue = func(context.Context) (*Promotiontype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotiontypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotiontypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PromotiontypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTYPE sets the TYPE field.
func (m *PromotiontypeMutation) SetTYPE(s string) {
	m._TYPE = &s
}

// TYPE returns the TYPE value in the mutation.
func (m *PromotiontypeMutation) TYPE() (r string, exists bool) {
	v := m._TYPE
	if v == nil {
		return
	}
	return *v, true
}

// OldTYPE returns the old TYPE value of the Promotiontype.
// If the Promotiontype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PromotiontypeMutation) OldTYPE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTYPE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTYPE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTYPE: %w", err)
	}
	return oldValue.TYPE, nil
}

// ResetTYPE reset all changes of the "TYPE" field.
func (m *PromotiontypeMutation) ResetTYPE() {
	m._TYPE = nil
}

// AddPromotionIDs adds the promotion edge to Promotion by ids.
func (m *PromotiontypeMutation) AddPromotionIDs(ids ...int) {
	if m.promotion == nil {
		m.promotion = make(map[int]struct{})
	}
	for i := range ids {
		m.promotion[ids[i]] = struct{}{}
	}
}

// RemovePromotionIDs removes the promotion edge to Promotion by ids.
func (m *PromotiontypeMutation) RemovePromotionIDs(ids ...int) {
	if m.removedpromotion == nil {
		m.removedpromotion = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpromotion[ids[i]] = struct{}{}
	}
}

// RemovedPromotion returns the removed ids of promotion.
func (m *PromotiontypeMutation) RemovedPromotionIDs() (ids []int) {
	for id := range m.removedpromotion {
		ids = append(ids, id)
	}
	return
}

// PromotionIDs returns the promotion ids in the mutation.
func (m *PromotiontypeMutation) PromotionIDs() (ids []int) {
	for id := range m.promotion {
		ids = append(ids, id)
	}
	return
}

// ResetPromotion reset all changes of the "promotion" edge.
func (m *PromotiontypeMutation) ResetPromotion() {
	m.promotion = nil
	m.removedpromotion = nil
}

// Op returns the operation name.
func (m *PromotiontypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotiontype).
func (m *PromotiontypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PromotiontypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TYPE != nil {
		fields = append(fields, promotiontype.FieldTYPE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PromotiontypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotiontype.FieldTYPE:
		return m.TYPE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PromotiontypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotiontype.FieldTYPE:
		return m.OldTYPE(ctx)
	}
	return nil, fmt.Errorf("unknown Promotiontype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotiontypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotiontype.FieldTYPE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTYPE(v)
		return nil
	}
	return fmt.Errorf("unknown Promotiontype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PromotiontypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PromotiontypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PromotiontypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotiontype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PromotiontypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PromotiontypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotiontypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Promotiontype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PromotiontypeMutation) ResetField(name string) error {
	switch name {
	case promotiontype.FieldTYPE:
		m.ResetTYPE()
		return nil
	}
	return fmt.Errorf("unknown Promotiontype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PromotiontypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.promotion != nil {
		edges = append(edges, promotiontype.EdgePromotion)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PromotiontypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotiontype.EdgePromotion:
		ids := make([]ent.Value, 0, len(m.promotion))
		for id := range m.promotion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PromotiontypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpromotion != nil {
		edges = append(edges, promotiontype.EdgePromotion)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PromotiontypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotiontype.EdgePromotion:
		ids := make([]ent.Value, 0, len(m.removedpromotion))
		for id := range m.removedpromotion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PromotiontypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PromotiontypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PromotiontypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotiontype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PromotiontypeMutation) ResetEdge(name string) error {
	switch name {
	case promotiontype.EdgePromotion:
		m.ResetPromotion()
		return nil
	}
	return fmt.Errorf("unknown Promotiontype edge %s", name)
}

// SalaryMutation represents an operation that mutate the Salaries
// nodes in the graph.
type SalaryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_SALARY         *int
	add_SALARY      *int
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Salary, error)
}

var _ ent.Mutation = (*SalaryMutation)(nil)

// salaryOption allows to manage the mutation configuration using functional options.
type salaryOption func(*SalaryMutation)

// newSalaryMutation creates new mutation for $n.Name.
func newSalaryMutation(c config, op Op, opts ...salaryOption) *SalaryMutation {
	m := &SalaryMutation{
		config:        c,
		op:            op,
		typ:           TypeSalary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSalaryID sets the id field of the mutation.
func withSalaryID(id int) salaryOption {
	return func(m *SalaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Salary
		)
		m.oldValue = func(ctx context.Context) (*Salary, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Salary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSalary sets the old Salary of the mutation.
func withSalary(node *Salary) salaryOption {
	return func(m *SalaryMutation) {
		m.oldValue = func(context.Context) (*Salary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SalaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SalaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SalaryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSALARY sets the SALARY field.
func (m *SalaryMutation) SetSALARY(i int) {
	m._SALARY = &i
	m.add_SALARY = nil
}

// SALARY returns the SALARY value in the mutation.
func (m *SalaryMutation) SALARY() (r int, exists bool) {
	v := m._SALARY
	if v == nil {
		return
	}
	return *v, true
}

// OldSALARY returns the old SALARY value of the Salary.
// If the Salary object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SalaryMutation) OldSALARY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSALARY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSALARY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSALARY: %w", err)
	}
	return oldValue.SALARY, nil
}

// AddSALARY adds i to SALARY.
func (m *SalaryMutation) AddSALARY(i int) {
	if m.add_SALARY != nil {
		*m.add_SALARY += i
	} else {
		m.add_SALARY = &i
	}
}

// AddedSALARY returns the value that was added to the SALARY field in this mutation.
func (m *SalaryMutation) AddedSALARY() (r int, exists bool) {
	v := m.add_SALARY
	if v == nil {
		return
	}
	return *v, true
}

// ResetSALARY reset all changes of the "SALARY" field.
func (m *SalaryMutation) ResetSALARY() {
	m._SALARY = nil
	m.add_SALARY = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *SalaryMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *SalaryMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *SalaryMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *SalaryMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *SalaryMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *SalaryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Salary).
func (m *SalaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SalaryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._SALARY != nil {
		fields = append(fields, salary.FieldSALARY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SalaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case salary.FieldSALARY:
		return m.SALARY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SalaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case salary.FieldSALARY:
		return m.OldSALARY(ctx)
	}
	return nil, fmt.Errorf("unknown Salary field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SalaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case salary.FieldSALARY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSALARY(v)
		return nil
	}
	return fmt.Errorf("unknown Salary field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SalaryMutation) AddedFields() []string {
	var fields []string
	if m.add_SALARY != nil {
		fields = append(fields, salary.FieldSALARY)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SalaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case salary.FieldSALARY:
		return m.AddedSALARY()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SalaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case salary.FieldSALARY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSALARY(v)
		return nil
	}
	return fmt.Errorf("unknown Salary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SalaryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SalaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SalaryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Salary nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SalaryMutation) ResetField(name string) error {
	switch name {
	case salary.FieldSALARY:
		m.ResetSALARY()
		return nil
	}
	return fmt.Errorf("unknown Salary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SalaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, salary.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SalaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case salary.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SalaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, salary.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SalaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case salary.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SalaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SalaryMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SalaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Salary unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SalaryMutation) ResetEdge(name string) error {
	switch name {
	case salary.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Salary edge %s", name)
}

// ZoneMutation represents an operation that mutate the Zones
// nodes in the graph.
type ZoneMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_EQUIPMENTZONE   *string
	clearedFields    map[string]struct{}
	equipment        map[int]struct{}
	removedequipment map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Zone, error)
}

var _ ent.Mutation = (*ZoneMutation)(nil)

// zoneOption allows to manage the mutation configuration using functional options.
type zoneOption func(*ZoneMutation)

// newZoneMutation creates new mutation for $n.Name.
func newZoneMutation(c config, op Op, opts ...zoneOption) *ZoneMutation {
	m := &ZoneMutation{
		config:        c,
		op:            op,
		typ:           TypeZone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withZoneID sets the id field of the mutation.
func withZoneID(id int) zoneOption {
	return func(m *ZoneMutation) {
		var (
			err   error
			once  sync.Once
			value *Zone
		)
		m.oldValue = func(ctx context.Context) (*Zone, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Zone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withZone sets the old Zone of the mutation.
func withZone(node *Zone) zoneOption {
	return func(m *ZoneMutation) {
		m.oldValue = func(context.Context) (*Zone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ZoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ZoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ZoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEQUIPMENTZONE sets the EQUIPMENTZONE field.
func (m *ZoneMutation) SetEQUIPMENTZONE(s string) {
	m._EQUIPMENTZONE = &s
}

// EQUIPMENTZONE returns the EQUIPMENTZONE value in the mutation.
func (m *ZoneMutation) EQUIPMENTZONE() (r string, exists bool) {
	v := m._EQUIPMENTZONE
	if v == nil {
		return
	}
	return *v, true
}

// OldEQUIPMENTZONE returns the old EQUIPMENTZONE value of the Zone.
// If the Zone object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ZoneMutation) OldEQUIPMENTZONE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEQUIPMENTZONE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEQUIPMENTZONE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEQUIPMENTZONE: %w", err)
	}
	return oldValue.EQUIPMENTZONE, nil
}

// ResetEQUIPMENTZONE reset all changes of the "EQUIPMENTZONE" field.
func (m *ZoneMutation) ResetEQUIPMENTZONE() {
	m._EQUIPMENTZONE = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *ZoneMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *ZoneMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *ZoneMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *ZoneMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *ZoneMutation) ResetEquipment() {
	m.equipment = nil
	m.removedequipment = nil
}

// Op returns the operation name.
func (m *ZoneMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Zone).
func (m *ZoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ZoneMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._EQUIPMENTZONE != nil {
		fields = append(fields, zone.FieldEQUIPMENTZONE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ZoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case zone.FieldEQUIPMENTZONE:
		return m.EQUIPMENTZONE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ZoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case zone.FieldEQUIPMENTZONE:
		return m.OldEQUIPMENTZONE(ctx)
	}
	return nil, fmt.Errorf("unknown Zone field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ZoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case zone.FieldEQUIPMENTZONE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEQUIPMENTZONE(v)
		return nil
	}
	return fmt.Errorf("unknown Zone field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ZoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ZoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ZoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Zone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ZoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ZoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ZoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Zone nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ZoneMutation) ResetField(name string) error {
	switch name {
	case zone.FieldEQUIPMENTZONE:
		m.ResetEQUIPMENTZONE()
		return nil
	}
	return fmt.Errorf("unknown Zone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ZoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, zone.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ZoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case zone.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ZoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedequipment != nil {
		edges = append(edges, zone.EdgeEquipment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ZoneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case zone.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ZoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ZoneMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ZoneMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Zone unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ZoneMutation) ResetEdge(name string) error {
	switch name {
	case zone.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Zone edge %s", name)
}
